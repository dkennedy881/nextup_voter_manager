{
  "_id" : "jimp",
  "_rev" : "313-e085cf1efceeae4d2aadad4b600b43e1",
  "name" : "jimp",
  "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
  "dist-tags" : {
    "canary" : "0.16.2-canary.938.1059.0",
    "latest" : "0.16.1"
  },
  "versions" : {
    "0.2.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.4",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.4.tgz",
        "shasum" : "c231d8f5152b6680c666c3bdc0e5a92b44fa8933"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "file-type" : "^2.6.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "node-png" : "^0.4.3",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.7.4",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.4",
      "gitHead" : "5cb5a3c8d746b971a5ccaa53fe9b57394b1eda52",
      "_shasum" : "c231d8f5152b6680c666c3bdc0e5a92b44fa8933",
      "_nodeVersion" : "0.12.2"
    },
    "0.6.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.6.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.0.tgz",
        "shasum" : "b0fc278a3313a4136bc9d352e0e81e56eb8c864a"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.0",
        "@jimp/plugins" : "^0.6.0",
        "@jimp/types" : "^0.6.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.0",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "ff78c045c32a9fff55f7fd92f72fa57409126485",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.0_1543433064261_0.029363219530502693"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.2.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.5",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.5.tgz",
        "shasum" : "fc16a93ed95ff2ff532adf69d90c7b4d55250158"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "file-type" : "^2.6.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs2" : "^1.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.5",
      "gitHead" : "6a3123ebcb2e1edde1779aa8947d667dc26ad8bd",
      "_shasum" : "fc16a93ed95ff2ff532adf69d90c7b4d55250158",
      "_nodeVersion" : "0.12.7"
    },
    "0.6.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.6.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.1.tgz",
        "shasum" : "4d51fde35fe7e0416b9375f80a000836f1f9adf4"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.0",
        "@jimp/plugins" : "^0.6.1",
        "@jimp/types" : "^0.6.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.0",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.1",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "495fa8852fde16bada8bbdf6433ab2f197a4d35e",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.1_1553803091241_0.3646636820777871"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.2.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.2",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.2.tgz",
        "shasum" : "5df3ebcbce840a4afe7b0785f51655e496e3126b"
      },
      "dependencies" : {
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "stream-to-buffer" : "~0.1.0",
        "node-png" : "~0.4.3",
        "file-type" : "~2.5.0",
        "read-chunk" : "~1.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.7.4",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.2",
      "gitHead" : "2e539313f63ce8d096457acbbd7e0b173c9f60df",
      "_shasum" : "5df3ebcbce840a4afe7b0785f51655e496e3126b",
      "_nodeVersion" : "0.12.2"
    },
    "0.2.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.3",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.3.tgz",
        "shasum" : "c25dcafc77662c903f707360c0ee988b7677d142"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "file-type" : "~2.5.0",
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "node-png" : "~0.4.3",
        "read-chunk" : "~1.0.1",
        "stream-to-buffer" : "~0.1.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.7.4",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.3",
      "gitHead" : "edb71a2f9c9d4b7ac2b04e25004e199f2317bfd9",
      "_shasum" : "c25dcafc77662c903f707360c0ee988b7677d142",
      "_nodeVersion" : "0.12.2"
    },
    "0.2.8" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.8",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.8.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.8.tgz",
        "shasum" : "b0623104b5c2c241c3cce699c795735fa1de14e8"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "file-type" : "^2.10.2",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs2" : "^1.2.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.8",
      "gitHead" : "9d18463d7ca4a5565e33fe4b51ee5439808b23c3",
      "_shasum" : "b0623104b5c2c241c3cce699c795735fa1de14e8",
      "_nodeVersion" : "0.12.7"
    },
    "0.6.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.4",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.4.tgz",
        "shasum" : "266c5777752a6edb4227792ef288198a1e99102f"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.4",
        "@jimp/plugins" : "^0.6.4",
        "@jimp/types" : "^0.6.4",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.4",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.11.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.4",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "7c9d3c817cade88d4a20422be10670d3c1528429",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.4_1556397762038_0.7414019606216216"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.2.9" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.9",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.9.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.9.tgz",
        "shasum" : "4d04a47680fa10ba93bb14b5a899265bd9bd3238"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "file-type" : "^2.10.2",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs2" : "^1.2.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.9",
      "gitHead" : "003aa2ed657c2349941180494be78b85e5bfdb64",
      "_shasum" : "4d04a47680fa10ba93bb14b5a899265bd9bd3238",
      "_nodeVersion" : "0.12.7"
    },
    "0.6.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.5",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.5.tgz",
        "shasum" : "861f4d35832e44d290a63b842c35cfbf54c2b112"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.5",
        "@jimp/plugins" : "^0.6.5",
        "@jimp/types" : "^0.6.5",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.5",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.5",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "b240287a362fdbc2baaea2a18d82c21b0777fd8c",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.5_1567473007409_0.5105708001243647"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.6.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.6.2",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.2.tgz",
        "shasum" : "6f393a7d71982b708d945ff937504f55c41aed8a"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.2",
        "@jimp/plugins" : "^0.6.2",
        "@jimp/types" : "^0.6.2",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.2",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.11.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.2",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "6d52efed23e47bb6f7c27bb2ae9e119d05db4dd3",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.2_1556388065432_0.8335608855757408"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.2.7" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.7",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.7.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.7.tgz",
        "shasum" : "946a5d98b1aaab7576fe44393cddc5997e6df4f5"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "file-type" : "^2.10.2",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs2" : "^1.2.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.7",
      "gitHead" : "ae6b29f2442bc214ac11a56963e6df5c0ba3166c",
      "_shasum" : "946a5d98b1aaab7576fe44393cddc5997e6df4f5",
      "_nodeVersion" : "0.12.7"
    },
    "0.6.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.3",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.3.tgz",
        "shasum" : "c844746a2f12f95a435f6a665d7560eee9e31abb"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.2",
        "@jimp/plugins" : "^0.6.2",
        "@jimp/types" : "^0.6.2",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.2",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.11.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.3",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "15094e4c3a941e2dff314f6808f076332596f612",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.3_1556396652038_0.17658932695451512"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.2.28" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.28",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.28.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.28.tgz",
        "shasum" : "dd529a937190f42957a7937d1acc3a7762996ea2"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.3",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.2.0",
        "load-bmfont" : "^1.2.3",
        "mime" : "^1.3.4",
        "mkdirp" : "0.5.1",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^3.0.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^14.3.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "minify-jimp" : "uglifyjs browser/tmp.jimp.js --compress warnings=false --mangle -o browser/tmp.jimp.min.js",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.28",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "f207a81d34640fb56e2f76ae53a1a11b44455ea7",
      "types" : "./jimp.d.ts",
      "browser" : "browser/lib/jimp.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp-0.2.28.tgz_1495329745869_0.305526859825477"
      },
      "_shasum" : "dd529a937190f42957a7937d1acc3a7762996ea2",
      "_nodeVersion" : "5.4.0"
    },
    "0.8.1-canary.786.211.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.786.211.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.786.211.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.786.211.0.tgz",
        "shasum" : "6a323a141bba23340af7f75650507a241dedde5d"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.786.211.0",
        "@jimp/plugins" : "0.8.1-canary.786.211.0",
        "@jimp/types" : "0.8.1-canary.786.211.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.786.211.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.786.211.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "14314180ede2041c8ae050d013baf39f0c8afbd1",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.786.211.0_1568081640475_0.9313221553718147"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.2-canary.792.332.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.332.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.332.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.332.0.tgz",
        "shasum" : "895d116e20553978504ba502fbd3b99435860fb6"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.332.0",
        "@jimp/plugins" : "0.8.2-canary.792.332.0",
        "@jimp/types" : "0.8.2-canary.792.332.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.332.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.332.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "3c22c39d67bb001aae84b2165e4f1f23b3cf84f2",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.332.0_1568745338589_0.2745694608870244"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.10.2-canary.875.842.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.2-canary.875.842.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.2-canary.875.842.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.2-canary.875.842.0.tgz",
        "shasum" : "691205224807d657c547c3f01ef454bd37caa63b"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.10.2-canary.875.842.0",
        "@jimp/plugins" : "0.10.2-canary.875.842.0",
        "@jimp/types" : "0.10.2-canary.875.842.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.10.2-canary.875.842.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.2-canary.875.842.0",
      "gitHead" : "0b0c586b4f487faa0c58261dcb032e983489169c",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.2-canary.875.842.0_1586870726308_0.7049939273887831"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.20.0"
    },
    "0.9.6-canary.857.681.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.6-canary.857.681.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.6-canary.857.681.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.6-canary.857.681.0.tgz",
        "shasum" : "71173dcff298fad91662fe5ea131473ae9e91a42"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.6-canary.857.681.0",
        "@jimp/plugins" : "0.9.6-canary.857.681.0",
        "@jimp/types" : "0.9.6-canary.857.681.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.6-canary.857.681.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.6-canary.857.681.0",
      "gitHead" : "002d4f41ee10762e19853545cdfc08427f748303",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.6-canary.857.681.0_1584552805782_0.4696545289895584"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.10.5-canary.882.886.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.5-canary.882.886.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.5-canary.882.886.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.5-canary.882.886.0.tgz",
        "shasum" : "625184ad39004b7e3b5edffba4baa26fe20baaa5"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.10.5-canary.882.886.0",
        "@jimp/plugins" : "0.10.5-canary.882.886.0",
        "@jimp/types" : "0.10.5-canary.882.886.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.10.5-canary.882.886.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.5-canary.882.886.0",
      "gitHead" : "2d20976992dc3dcd2ced010be15a1da07604749c",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.5-canary.882.886.0_1588390734516_0.6032120469679563"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.20.1"
    },
    "0.2.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.0",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.0.tgz",
        "shasum" : "b652c501716c273da276526c95ef80fc9bd73ad5"
      },
      "dependencies" : {
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "stream-to-buffer" : "~0.1.0",
        "node-png" : "~0.4.3",
        "file-type" : "~2.5.0",
        "read-chunk" : "~1.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.7.4",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.0",
      "gitHead" : "ee1445a0a9017f3d0e18d2f9f0415fba22986e2a",
      "_shasum" : "b652c501716c273da276526c95ef80fc9bd73ad5",
      "_nodeVersion" : "0.12.2"
    },
    "0.2.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.1",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.1.tgz",
        "shasum" : "180a62862e5c5150e49bc19dd1952c34de44d6d9"
      },
      "dependencies" : {
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "stream-to-buffer" : "~0.1.0",
        "node-png" : "~0.4.3",
        "file-type" : "~2.5.0",
        "read-chunk" : "~1.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.7.4",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.1",
      "gitHead" : "f706321e915e23fa63a972f96bdb188fe9dfda5f",
      "_shasum" : "180a62862e5c5150e49bc19dd1952c34de44d6d9",
      "_nodeVersion" : "0.12.2"
    },
    "0.8.5-canary.b147e81.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.5-canary.b147e81.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.5-canary.b147e81.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.5-canary.b147e81.0.tgz",
        "shasum" : "e31edbab912a205362459b0e3662b52f915d3e1f"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.5-canary.b147e81.0",
        "@jimp/plugins" : "0.8.5-canary.b147e81.0",
        "@jimp/types" : "0.8.5-canary.b147e81.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "0.8.5-canary.b147e81.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.15.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.5-canary.b147e81.0",
      "gitHead" : "b147e810972b2bba9bea4a132c3026ca119832e7",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.5-canary.b147e81.0_1569358150697_0.46378292452697045"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n**Note**: This change in import does not change the runtime behavior of your code at all.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.15.0"
    },
    "0.8.1-canary.789.460.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.789.460.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.789.460.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.789.460.0.tgz",
        "shasum" : "e8b3662cf6cc610c1cc637c28ab6741b2ee73b56"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.789.460.0",
        "@jimp/plugins" : "0.8.1-canary.789.460.0",
        "@jimp/types" : "0.8.1-canary.789.460.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.789.460.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.789.460.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "7eee535c2a838803b49844f90c4d118b8a5683b6",
      "types" : "index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.789.460.0_1569490109288_0.6251166433953164"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.6-canary.858.667.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.6-canary.858.667.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.6-canary.858.667.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.6-canary.858.667.0.tgz",
        "shasum" : "2c4ae78cde2c8007aabdd7162b57b2e6b6dbe245"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.6-canary.858.667.0",
        "@jimp/plugins" : "0.9.6-canary.858.667.0",
        "@jimp/types" : "0.9.6-canary.858.667.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.6-canary.858.667.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.6-canary.858.667.0",
      "gitHead" : "840d8f4c4093fe094d5257c9d9d7c47fadd76034",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.6-canary.858.667.0_1584549456044_0.2636788554547067"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.12.1-canary.892.924.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.12.1-canary.892.924.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.12.1-canary.892.924.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.12.1-canary.892.924.0.tgz",
        "shasum" : "8b4db7225f0d4c939a41332de30903f09b0aff0a"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.12.1-canary.892.924.0",
        "@jimp/plugins" : "0.12.1-canary.892.924.0",
        "@jimp/types" : "0.12.1-canary.892.924.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.12.1-canary.892.924.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.12.1-canary.892.924.0",
      "gitHead" : "6f877e86e4dc5817f4a8710a1dbf86a983aacc0f",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.12.1-canary.892.924.0_1589869224369_0.7218225190696332"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.20.1"
    },
    "0.10.4-canary.882.884.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.4-canary.882.884.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.4-canary.882.884.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.4-canary.882.884.0.tgz",
        "shasum" : "8f2700b0ad362bc6e5e9f5fd046f3263ab5b5db9"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.10.4-canary.882.884.0",
        "@jimp/plugins" : "0.10.4-canary.882.884.0",
        "@jimp/types" : "0.10.4-canary.882.884.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.10.4-canary.882.884.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.4-canary.882.884.0",
      "gitHead" : "5a9c3fb1790f93d37ef380a2127fef7aac313db5",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.4-canary.882.884.0_1588390629491_0.4325488333941645"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.20.1"
    },
    "0.16.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.16.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.16.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.16.1.tgz",
        "shasum" : "192f851a30e5ca11112a3d0aa53137659a78ca7a"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.16.1",
        "@jimp/plugins" : "^0.16.1",
        "@jimp/types" : "^0.16.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.16.1",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.16.1",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "909f06eac36ef5ba36ebb1e0853fd006c4da3560",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.16.1_1598635275185_0.58239965647006"
      },
      "_nodeVersion" : "10.22.0"
    },
    "0.16.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.16.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.16.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.16.0.tgz",
        "shasum" : "d01a1709634c22aa113df02076dbe4db7ca55acc"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.16.0",
        "@jimp/plugins" : "^0.16.0",
        "@jimp/types" : "^0.16.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.16.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.16.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "6b013225f12739762bf946dc4a00f34bafaf61ec",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.16.0_1596846468091_0.030604406291648845"
      },
      "_nodeVersion" : "10.22.0"
    },
    "0.12.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.12.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.12.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.12.1.tgz",
        "shasum" : "3e58fdd16ebb2b8f00a09be3dd5c54f79ffae04a"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.12.1",
        "@jimp/plugins" : "^0.12.1",
        "@jimp/types" : "^0.12.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.12.1",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.12.1",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "942e635564e36fc243767531b4f8be036afa40b5",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.12.1_1589869854326_0.11532625453708323"
      },
      "_nodeVersion" : "10.20.1"
    },
    "0.12.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.12.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.12.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.12.0.tgz",
        "shasum" : "7e0d9d6b0c9c52dec0fd0d567ac1ba62fed9a89d"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.12.0",
        "@jimp/plugins" : "^0.12.0",
        "@jimp/types" : "^0.12.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.12.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.12.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2b3413a12995f7f3fdfb9dfd19ba9268734c6400",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.12.0_1589675681609_0.8938657643045671"
      },
      "_nodeVersion" : "10.20.1"
    },
    "0.8.1-canary.789.301.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.789.301.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.789.301.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.789.301.0.tgz",
        "shasum" : "692425463d6e8eb03c29c194c8d7bc48832a264b"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.789.301.0",
        "@jimp/plugins" : "0.8.1-canary.789.301.0",
        "@jimp/types" : "0.8.1-canary.789.301.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.789.301.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.789.301.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "b74e13e54badf24f2df94e7e1d1a6c960aab8ff6",
      "types" : "index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.789.301.0_1568360412326_0.555401444812117"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.4-canary.838.613.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.4-canary.838.613.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.4-canary.838.613.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.4-canary.838.613.0.tgz",
        "shasum" : "27adc1be7e11bed604bc59244ae6aea95b40fe93"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.4-canary.838.613.0",
        "@jimp/plugins" : "0.9.4-canary.838.613.0",
        "@jimp/types" : "0.9.4-canary.838.613.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.4-canary.838.613.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.4-canary.838.613.0",
      "gitHead" : "c58a4dfea857b88949d0891906c31cda66345ded",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.4-canary.838.613.0_1578583961739_0.2696700727704897"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.2-canary.794.308.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.794.308.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.794.308.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.794.308.0.tgz",
        "shasum" : "d6e5ecac08a06a3277df19353fd7559a527b9c76"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.794.308.0",
        "@jimp/plugins" : "0.8.2-canary.794.308.0",
        "@jimp/types" : "0.8.2-canary.794.308.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.794.308.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.794.308.0",
      "gitHead" : "b934a6eb4448269ef21bbeba851f9417398d1f89",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.794.308.0_1568394420994_0.6495138543739558"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.9-canary.867.792.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.9-canary.867.792.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.9-canary.867.792.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.9-canary.867.792.0.tgz",
        "shasum" : "672de225c090d54fe6ec6bf61bd92be473b32dc4"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.9-canary.867.792.0",
        "@jimp/plugins" : "0.9.9-canary.867.792.0",
        "@jimp/types" : "0.9.9-canary.867.792.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.9-canary.867.792.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.9-canary.867.792.0",
      "gitHead" : "e05689ace8f60a7f4d031924f06d8ccdfa5bd05b",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.9-canary.867.792.0_1585522001440_0.6540905840803724"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.19.0"
    },
    "0.8.1-canary.791.276.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.791.276.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.791.276.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.791.276.0.tgz",
        "shasum" : "4cf6daa871d4855d1cdd3e8d86a9eb9717f266e4"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.791.276.0",
        "@jimp/plugins" : "0.8.1-canary.791.276.0",
        "@jimp/types" : "0.8.1-canary.791.276.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.791.276.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.791.276.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "10c0813de0db0d8460b082ac9944d638a8c387fc",
      "types" : "index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.791.276.0_1568282247783_0.49859592946229037"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.5-canary.1.b147e81.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.5-canary.1.b147e81.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.5-canary.1.b147e81.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.5-canary.1.b147e81.0.tgz",
        "shasum" : "29ba73535d7dcd0314bdb6bafec3a6b5bf92d844"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.5-canary.1.b147e81.0",
        "@jimp/plugins" : "0.8.5-canary.1.b147e81.0",
        "@jimp/types" : "0.8.5-canary.1.b147e81.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "0.8.5-canary.1.b147e81.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.5-canary.1.b147e81.0",
      "gitHead" : "b147e810972b2bba9bea4a132c3026ca119832e7",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.5-canary.1.b147e81.0_1569358744269_0.009217547709513774"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n**Note**: This change in import does not change the runtime behavior of your code at all.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.4-canary.832.606.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.4-canary.832.606.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.4-canary.832.606.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.4-canary.832.606.0.tgz",
        "shasum" : "3dd23339aca963cb51ffd833e9f0d6873b6c82c5"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.4-canary.832.606.0",
        "@jimp/plugins" : "0.9.4-canary.832.606.0",
        "@jimp/types" : "0.9.4-canary.832.606.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.4-canary.832.606.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.4-canary.832.606.0",
      "gitHead" : "b699e66246ac0d4eb6a75d13a4275a84ad3d7d85",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.4-canary.832.606.0_1577492800503_0.23044985527454886"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.3.10" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.10",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.10.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.10.tgz",
        "shasum" : "10367fbcb9cdde25c19dcaae30770c1977ec2e0e"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.3.9",
        "@jimp/plugins" : "^0.3.10",
        "@jimp/types" : "^0.3.9",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^13.0.1",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.8",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.3.10.tgz",
      "_npmVersion" : "6.2.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.10",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "5acf8bc88e2f086e9be6762b336fd18c2d147175",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.10_1535596982559_0.6920643416476369"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.8.0"
    },
    "0.16.2-canary.934.1053.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.16.2-canary.934.1053.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.16.2-canary.934.1053.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.16.2-canary.934.1053.0.tgz",
        "shasum" : "419a1e38f4d79745cfad79e913b375b3e22f43d8"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.16.2-canary.934.1053.0",
        "@jimp/plugins" : "0.16.2-canary.934.1053.0",
        "@jimp/types" : "0.16.2-canary.934.1053.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.16.2-canary.934.1053.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.16.2-canary.934.1053.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "7af955a9ed6dd3a78894ba5f6b4c893dab517057",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.16.2-canary.934.1053.0_1598635478551_0.35223811527115667"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.22.0"
    },
    "0.3.11" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.11",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.11.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.11.tgz",
        "shasum" : "187ca4633198a43705113d82a559ae850f17247a"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.3.9",
        "@jimp/plugins" : "^0.3.10",
        "@jimp/types" : "^0.3.9",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^13.0.1",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.8",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.3.11.tgz",
      "_npmVersion" : "6.2.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.11",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2c1e45fd9a97e05046705931f05221a78e2675aa",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.11_1535617100110_0.5767613016068296"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.8.0"
    },
    "0.6.5-canary.784.124.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.5-canary.784.124.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.5-canary.784.124.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.5-canary.784.124.0.tgz",
        "shasum" : "7a6abeca3444224b6b710792c1f7423843c0363e"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "0.6.5-canary.784.124.0",
        "@jimp/plugins" : "0.6.5-canary.784.124.0",
        "@jimp/types" : "0.6.5-canary.784.124.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.6.5-canary.784.124.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.5-canary.784.124.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2c1e4c04e7e0dc08526c9188009808f02bf886fd",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.5-canary.784.124.0_1567471910796_0.13293756513443045"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\nAlign Mode | Axis Point\n--- | ---\n`Jimp.HORIZONTAL_ALIGN_LEFT` | Positions the x-axis at the left of the image\n`Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image\n`Jimp.HORIZONTAL_ALIGN_RIGHT` | Positions the x-axis at the right of the image\n`Jimp.VERTICAL_ALIGN_TOP` | Positions the y-axis at the top of the image\n`Jimp.VERTICAL_ALIGN_MIDDLE` | Positions the y-axis at the center of the image\n`Jimp.VERTICAL_ALIGN_BOTTOM` | Positions the y-axis at the bottom of the image\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.3.9" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.9",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.9.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.9.tgz",
        "shasum" : "8ba7235265f0357a31c254a021d077b96532e274"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@jimp/custom" : "^0.3.9",
        "@jimp/plugins" : "^0.3.9",
        "@jimp/types" : "^0.3.9",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.9",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "cc0669daf5b35d7bb0cb9d2a07a3ab4215bbed79",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.9_1535416118636_0.7954835188390037"
      },
      "_nodeVersion" : "9.10.0"
    },
    "0.11.1-canary.891.908.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.11.1-canary.891.908.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.11.1-canary.891.908.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.11.1-canary.891.908.0.tgz",
        "shasum" : "febd7dcbb904f357d5bb568848a9658fcf8c3914"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.11.1-canary.891.908.0",
        "@jimp/plugins" : "0.11.1-canary.891.908.0",
        "@jimp/types" : "0.11.1-canary.891.908.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.11.1-canary.891.908.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.11.1-canary.891.908.0",
      "gitHead" : "8fbf0a27694e699539d5281afa06770516a5cfd4",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.11.1-canary.891.908.0_1589653425597_0.6945741264662972"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.20.1"
    },
    "0.5.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.1.tgz",
        "shasum" : "4b29020302a4a373f16c8ca334beb0467fce691d"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.1",
        "@jimp/plugins" : "^0.5.1",
        "@jimp/types" : "^0.5.1",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.1",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.5.1.tgz",
      "_npmVersion" : "6.2.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.1",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "b23ab92550336eed5d4ac422564c7c63ea280c73",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.1_1537734387734_0.9088819806549384"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.8.0"
    },
    "0.5.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.2",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.2.tgz",
        "shasum" : "e7fc7d91fcb255a277de1f3b41f9df6ce73050e7"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.2",
        "@jimp/plugins" : "^0.5.2",
        "@jimp/types" : "^0.5.2",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.2",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.5.2.tgz",
      "_npmVersion" : "6.2.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.2",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "206fa4a372f89b6b3ea87d73656066a0baf055d6",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.2_1537736060526_0.6403416381020199"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.8.0"
    },
    "0.1.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.1.3",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.1.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.1.3.tgz",
        "shasum" : "6efa1d6586dff5fa79f6bd52f6c5fcab934fffcd"
      },
      "dependencies" : {
        "pngjs" : "~0.4.0",
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "node-bitmap" : "0.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "1.3.21",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.1.3"
    },
    "0.1.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.1.4",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.1.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.1.4.tgz",
        "shasum" : "f5004b63fcc6058d1549cdc2fbedbe7efc351489"
      },
      "dependencies" : {
        "pngjs" : "~0.4.0",
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "node-bitmap" : "0.0.1",
        "stream-to-buffer" : "~0.1.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "1.3.21",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.1.4"
    },
    "0.5.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.0.tgz",
        "shasum" : "ffc1c833d32ba2ab3589ffa9719eee0676b20bf3"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.0",
        "@jimp/plugins" : "^0.5.0",
        "@jimp/types" : "^0.5.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.0",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "fbbe0b7da5a9dcf8da35e2dfb2e8265ca850435c",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.0_1537043365628_0.9504820250340851"
      },
      "_nodeVersion" : "9.10.0"
    },
    "0.5.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.5",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.5.tgz",
        "shasum" : "8b003cb6d909c33dd2c43b88fff9d5f5095d054f"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.4",
        "@jimp/plugins" : "^0.5.5",
        "@jimp/types" : "^0.5.4",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.4",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.5",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "72634d1c6c614a925bf1bc5e861e3640f5c0bf98",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.5_1540519096919_0.40042728767612235"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.9.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.1.tgz",
        "shasum" : "7343db1370c3ec6969468a32347bfd0bd2fa4d98"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.9.1",
        "@jimp/plugins" : "^0.9.1",
        "@jimp/types" : "^0.9.1",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "^0.9.1",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.1",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "c6f11425c0e8585a73109d61d3372612bfa3799f",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.1_1574790069249_0.6368031468248965"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.5.6" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.6",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.6.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.6.tgz",
        "shasum" : "dd114decd060927ae439f2e0980df619c179f912"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.4",
        "@jimp/plugins" : "^0.5.5",
        "@jimp/types" : "^0.5.4",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.4",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.6",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "14055cf60e66701987bb148a2d389844dd0e9cb4",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.6_1540520537995_0.32148703501004383"
      },
      "_nodeVersion" : "8.11.0"
    },
    "0.5.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.3",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.3.tgz",
        "shasum" : "6f411ee4eb459686f6f8e11a31faa08c6dfac922"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.3",
        "@jimp/plugins" : "^0.5.3",
        "@jimp/types" : "^0.5.3",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.3",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.5.3.tgz",
      "_npmVersion" : "6.2.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.3",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "762e7e5f8099996f7bfb580477e29a75694e564e",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.3_1537737283575_0.5142808354485899"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.8.0"
    },
    "0.5.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.5.4",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.5.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.5.4.tgz",
        "shasum" : "f0d32bf06f77f3af61f2830f18ab82a3df689c70"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.5.4",
        "@jimp/plugins" : "^0.5.4",
        "@jimp/types" : "^0.5.4",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.5.4",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.5.4.tgz",
      "_npmVersion" : "6.4.1",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.5.4",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "833308a04a490b760425b9caadd6409cb345a582",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.5.4_1539325244375_0.4910928365237939"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.11.0"
    },
    "0.9.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.0.tgz",
        "shasum" : "01ff6df8483b46f854b9953e2e4eb6f558e22b8c"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.9.0",
        "@jimp/plugins" : "^0.9.0",
        "@jimp/types" : "^0.9.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "^0.9.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "0591e7391f64a92084a4ce9c96a1274df6339c25",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.0_1574788120274_0.5970189626558797"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.6.7-canary.783.157.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.7-canary.783.157.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.7-canary.783.157.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.7-canary.783.157.0.tgz",
        "shasum" : "e86330929ad842d43c99fa731f5dc1ba5e85ca82"
      },
      "dependencies" : {
        "@jimp/custom" : "0.6.7-canary.783.157.0",
        "@jimp/plugins" : "0.6.7-canary.783.157.0",
        "@jimp/types" : "0.6.7-canary.783.157.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.6.7-canary.783.157.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.7-canary.783.157.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "a1f0b247580b7bc0c94b6964b9b277e0a2e99e9e",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.7-canary.783.157.0_1567474133671_0.396757864591577"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\nAlign Mode | Axis Point\n--- | ---\n`Jimp.HORIZONTAL_ALIGN_LEFT` | Positions the x-axis at the left of the image\n`Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image\n`Jimp.HORIZONTAL_ALIGN_RIGHT` | Positions the x-axis at the right of the image\n`Jimp.VERTICAL_ALIGN_TOP` | Positions the y-axis at the top of the image\n`Jimp.VERTICAL_ALIGN_MIDDLE` | Positions the y-axis at the center of the image\n`Jimp.VERTICAL_ALIGN_BOTTOM` | Positions the y-axis at the bottom of the image\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.1.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.1.1",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.1.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.1.1.tgz",
        "shasum" : "8b14c841a1b12d81ff0b45fb1e7d02a6dea1d571"
      },
      "dependencies" : {
        "pngjs" : "~0.4.0",
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "1.3.21",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.1.1"
    },
    "0.1.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.1.2",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.1.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.1.2.tgz",
        "shasum" : "04b52aad3929f6d06b9cb318842cc7df1734473b"
      },
      "dependencies" : {
        "pngjs" : "~0.4.0",
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11",
        "node-bitmap" : "0.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "1.3.21",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.1.2"
    },
    "0.1.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.1.0",
      "main" : "jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.1.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.1.0.tgz",
        "shasum" : "f35d7c24fc286229b062809d6e611995f2fd0663"
      },
      "dependencies" : {
        "pngjs" : "~0.4.0",
        "jpeg-js" : "0.0.4",
        "mime" : "~1.2.11"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "1.3.21",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.1.0"
    },
    "0.8.2-canary.792.339.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.339.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.339.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.339.0.tgz",
        "shasum" : "d7dcc03a281af727bd01326c8f0e0f8d711de72d"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.339.0",
        "@jimp/plugins" : "0.8.2-canary.792.339.0",
        "@jimp/types" : "0.8.2-canary.792.339.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.339.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.339.0",
      "gitHead" : "1596cf9eb0dfce7fdbd1c7636e613bfb5bb5f1a3",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.339.0_1568761346666_0.10871716659060149"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.9-canary.868.799.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.9-canary.868.799.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.9-canary.868.799.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.9-canary.868.799.0.tgz",
        "shasum" : "d9d5f085c39d91977073b7bc3d828a5496803684"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.9-canary.868.799.0",
        "@jimp/plugins" : "0.9.9-canary.868.799.0",
        "@jimp/types" : "0.9.9-canary.868.799.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.9-canary.868.799.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.9-canary.868.799.0",
      "gitHead" : "43ad540880302d7c8793ec393698d0dc2bc32e87",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.9-canary.868.799.0_1585531011169_0.15584393833239285"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.19.0"
    },
    "0.6.5-canary.784.118.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.5-canary.784.118.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.5-canary.784.118.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.5-canary.784.118.0.tgz",
        "shasum" : "3cf1b847e412b3af0dc95ba4e5355567651bd6de"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "0.6.5-canary.784.118.0",
        "@jimp/plugins" : "0.6.5-canary.784.118.0",
        "@jimp/types" : "0.6.5-canary.784.118.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.6.5-canary.784.118.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.5-canary.784.118.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "20a24e11c6ef9b5ff9ed731f9a2d356fb8142518",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.5-canary.784.118.0_1567471429129_0.4938198618751293"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\nAlign Mode | Axis Point\n--- | ---\n`Jimp.HORIZONTAL_ALIGN_LEFT` | Positions the x-axis at the left of the image\n`Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image\n`Jimp.HORIZONTAL_ALIGN_RIGHT` | Positions the x-axis at the right of the image\n`Jimp.VERTICAL_ALIGN_TOP` | Positions the y-axis at the top of the image\n`Jimp.VERTICAL_ALIGN_MIDDLE` | Positions the y-axis at the center of the image\n`Jimp.VERTICAL_ALIGN_BOTTOM` | Positions the y-axis at the bottom of the image\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.6.8-canary.783.163.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.8-canary.783.163.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.8-canary.783.163.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.8-canary.783.163.0.tgz",
        "shasum" : "b8d621c96e2755c9537332091e9761e336a0234e"
      },
      "dependencies" : {
        "@jimp/custom" : "0.6.8-canary.783.163.0",
        "@jimp/plugins" : "0.6.8-canary.783.163.0",
        "@jimp/types" : "0.6.8-canary.783.163.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.6.8-canary.783.163.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.8-canary.783.163.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "7f6e1d7e6f2ccf5d862e7e97ca1b8235da2053d4",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.8-canary.783.163.0_1567486743120_0.2244345724209278"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\nAlign Mode | Axis Point\n--- | ---\n`Jimp.HORIZONTAL_ALIGN_LEFT` | Positions the x-axis at the left of the image\n`Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image\n`Jimp.HORIZONTAL_ALIGN_RIGHT` | Positions the x-axis at the right of the image\n`Jimp.VERTICAL_ALIGN_TOP` | Positions the y-axis at the top of the image\n`Jimp.VERTICAL_ALIGN_MIDDLE` | Positions the y-axis at the center of the image\n`Jimp.VERTICAL_ALIGN_BOTTOM` | Positions the y-axis at the bottom of the image\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.6.5-canary.4564f3c.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.5-canary.4564f3c.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.5-canary.4564f3c.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.5-canary.4564f3c.0.tgz",
        "shasum" : "0d6d37eca231fe92b09e33ed4823eeb7bcf0d78b"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "0.6.5-canary.4564f3c.0",
        "@jimp/plugins" : "0.6.5-canary.4564f3c.0",
        "@jimp/types" : "0.6.5-canary.4564f3c.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.6.5-canary.4564f3c.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v10.15.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.5-canary.4564f3c.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "4564f3c577d6a6f44199f0818cfe6c0d24a9daac",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.5-canary.4564f3c.0_1567468815151_0.520109071682592"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\nAlign Mode | Axis Point\n--- | ---\n`Jimp.HORIZONTAL_ALIGN_LEFT` | Positions the x-axis at the left of the image\n`Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image\n`Jimp.HORIZONTAL_ALIGN_RIGHT` | Positions the x-axis at the right of the image\n`Jimp.VERTICAL_ALIGN_TOP` | Positions the y-axis at the top of the image\n`Jimp.VERTICAL_ALIGN_MIDDLE` | Positions the y-axis at the center of the image\n`Jimp.VERTICAL_ALIGN_BOTTOM` | Positions the y-axis at the bottom of the image\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.15.0"
    },
    "0.14.1-canary.911.993.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.14.1-canary.911.993.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.14.1-canary.911.993.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.14.1-canary.911.993.0.tgz",
        "shasum" : "2558a8ad5396d6474e1dbea8e9b70b8dce8094ab"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.14.1-canary.911.993.0",
        "@jimp/plugins" : "0.14.1-canary.911.993.0",
        "@jimp/types" : "0.14.1-canary.911.993.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.14.1-canary.911.993.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.21.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.14.1-canary.911.993.0",
      "gitHead" : "911578e80f7abb355da61c429deba739fa411661",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.14.1-canary.911.993.0_1594924382115_0.963803826608818"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.21.0"
    },
    "0.10.4-canary.882.885.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.4-canary.882.885.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.4-canary.882.885.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.4-canary.882.885.0.tgz",
        "shasum" : "3938cb8a9d280ce5a1395993217854bccff875b0"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.10.4-canary.882.885.0",
        "@jimp/plugins" : "0.10.4-canary.882.885.0",
        "@jimp/types" : "0.10.4-canary.882.885.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.10.4-canary.882.885.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.4-canary.882.885.0",
      "gitHead" : "9c962bd2c1ca4e07770dbb6469e18b3727927ac9",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.4-canary.882.885.0_1588390613756_0.09680714924779443"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.20.1"
    },
    "0.9.4-canary.841.620.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.4-canary.841.620.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.4-canary.841.620.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.4-canary.841.620.0.tgz",
        "shasum" : "65c3b3795d72831719b6e6026be116aa3ff11485"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.4-canary.841.620.0",
        "@jimp/plugins" : "0.9.4-canary.841.620.0",
        "@jimp/types" : "0.9.4-canary.841.620.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.4-canary.841.620.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.4-canary.841.620.0",
      "gitHead" : "04c9ce5c5abeac1f632c376ff19a798e8f52b0e4",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.4-canary.841.620.0_1579994916469_0.14698321204299258"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.7.1-canary.770.193.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.7.1-canary.770.193.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.7.1-canary.770.193.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.7.1-canary.770.193.0.tgz",
        "shasum" : "71db53224e6ff538789d8081d6df4932b9e80a1c"
      },
      "dependencies" : {
        "@jimp/custom" : "0.7.1-canary.770.193.0",
        "@jimp/plugins" : "0.7.1-canary.770.193.0",
        "@jimp/types" : "0.7.1-canary.770.193.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.7.1-canary.770.193.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.7.1-canary.770.193.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "4eaccc589bda6d67853184da55c7e22c74c75676",
      "types" : "index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.7.1-canary.770.193.0_1567824555102_0.9358326522745037"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.6-canary.810.481.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.6-canary.810.481.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.6-canary.810.481.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.6-canary.810.481.0.tgz",
        "shasum" : "fece7b2089eb77d0bc30a32f5e5d1b87ba429a2d"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.6-canary.810.481.0",
        "@jimp/plugins" : "0.8.6-canary.810.481.0",
        "@jimp/types" : "0.8.6-canary.810.481.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "0.8.6-canary.810.481.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.6-canary.810.481.0",
      "gitHead" : "941ed08d9215f928708b7ab6a9a942a2fc5995df",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.6-canary.810.481.0_1572455769612_0.5777664399832054"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.15.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.15.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.15.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.15.0.tgz",
        "shasum" : "20eafa04d2142299b07ed9f9a3824f91c813798b"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.15.0",
        "@jimp/plugins" : "^0.15.0",
        "@jimp/types" : "^0.15.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.15.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.15.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "5e34fdf5f7b63d4fa00ec8f79c3e645730ccd987",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.15.0_1596831935074_0.24942901783562443"
      },
      "_nodeVersion" : "10.22.0"
    },
    "0.11.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.11.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.11.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.11.0.tgz",
        "shasum" : "a7239279da030c98e6ba00f39fbff2596e112849"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.11.0",
        "@jimp/plugins" : "^0.11.0",
        "@jimp/types" : "^0.11.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.11.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.11.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "ec736c9fb6aaf2b325db76819af4c3caea1f9ec8",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.11.0_1589577713070_0.3989299630900873"
      },
      "_nodeVersion" : "10.20.1"
    },
    "0.8.6-canary.815.502.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.6-canary.815.502.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.6-canary.815.502.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.6-canary.815.502.0.tgz",
        "shasum" : "a1fed7f00173b60c2c181a28959a02975d931645"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.8.6-canary.815.502.0",
        "@jimp/plugins" : "0.8.6-canary.815.502.0",
        "@jimp/types" : "0.8.6-canary.815.502.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.8.6-canary.815.502.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.6-canary.815.502.0",
      "gitHead" : "5a68a9702462d87d579c9a54c5170d4940a2991d",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.6-canary.815.502.0_1574201656482_0.025632506028181234"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.5-canary.800.426.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.5-canary.800.426.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.5-canary.800.426.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.5-canary.800.426.0.tgz",
        "shasum" : "e7085d3ecefc88578ab091332e0e815f24ba1513"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.5-canary.800.426.0",
        "@jimp/plugins" : "0.8.5-canary.800.426.0",
        "@jimp/types" : "0.8.5-canary.800.426.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.5-canary.800.426.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.5-canary.800.426.0",
      "gitHead" : "eea6165d7a8ee65bce94db45d530aa45bba72af1",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.5-canary.800.426.0_1569027238896_0.7532198115094739"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.3.6-alpha.6" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.6-alpha.6",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.6-alpha.6.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.6-alpha.6.tgz",
        "shasum" : "093b6023c6929d1312aabb814367b2109ef68fcc"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@jimp/custom" : "^0.3.6-alpha.6",
        "@jimp/plugins" : "^0.3.6-alpha.6",
        "@jimp/types" : "^0.3.6-alpha.6"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.6-alpha.6",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "c432eb631a023bf80d5457ef4673cb308d14ce59",
      "types" : "jimp.d.ts",
      "licenseText" : "The MIT License (MIT)\n\nCopyright (c) 2014 Oliver Moran\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.6-alpha.6_1535258385366_0.8409715094637922"
      }
    },
    "0.9.2-canary.815.538.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.2-canary.815.538.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.2-canary.815.538.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.2-canary.815.538.0.tgz",
        "shasum" : "748f4e136d38782d3b4f7dc339d65ccb9afb187b"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.2-canary.815.538.0",
        "@jimp/plugins" : "0.9.2-canary.815.538.0",
        "@jimp/types" : "0.9.2-canary.815.538.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.2-canary.815.538.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.2-canary.815.538.0",
      "gitHead" : "7d4c8b69bc33d98b760ad1e0acbe678ed03647f1",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.2-canary.815.538.0_1574799250809_0.14975018092822778"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.14.1-canary.919.1005.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.14.1-canary.919.1005.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.14.1-canary.919.1005.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.14.1-canary.919.1005.0.tgz",
        "shasum" : "ec23df5b6175655bcceeba4fb2126ec139fad8de"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.14.1-canary.919.1005.0",
        "@jimp/plugins" : "0.14.1-canary.919.1005.0",
        "@jimp/types" : "0.14.1-canary.919.1005.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.14.1-canary.919.1005.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.14.1-canary.919.1005.0",
      "gitHead" : "4e997ab650cef149810cbd3df60cee4507f588e8",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.14.1-canary.919.1005.0_1596109921359_0.7885230930163407"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.22.0"
    },
    "0.3.6-alpha.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.6-alpha.5",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.6-alpha.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.6-alpha.5.tgz",
        "shasum" : "63392e4ca1eebd1a51bab7321f130aa1ee85d257"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@jimp/custom" : "^0.3.6-alpha.5",
        "@jimp/plugins" : "^0.3.6-alpha.5",
        "@jimp/types" : "^0.3.6-alpha.5"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.6-alpha.5",
      "tonicExampleFilename" : "example.js",
      "types" : "jimp.d.ts",
      "licenseText" : "The MIT License (MIT)\n\nCopyright (c) 2014 Oliver Moran\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.6-alpha.5_1535257402286_0.2916412782986495"
      }
    },
    "0.13.0-canary.899.964.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.13.0-canary.899.964.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.13.0-canary.899.964.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.13.0-canary.899.964.0.tgz",
        "shasum" : "62aaf856a93dcdbf1d7b6c5df41d96e6914b3399"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.13.0-canary.899.964.0",
        "@jimp/plugins" : "0.13.0-canary.899.964.0",
        "@jimp/types" : "0.13.0-canary.899.964.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.13.0-canary.899.964.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.21.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.13.0-canary.899.964.0",
      "gitHead" : "238e21aefe491f4bb32cea2671c35d6d3e2756c9",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.13.0-canary.899.964.0_1591337099980_0.8244746935160456"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.21.0"
    },
    "0.8.6-canary.815.488.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.6-canary.815.488.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.6-canary.815.488.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.6-canary.815.488.0.tgz",
        "shasum" : "deb8dff0287316dd3c4c08dc19c1235f1527e71a"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.8.6-canary.815.488.0",
        "@jimp/plugins" : "0.8.6-canary.815.488.0",
        "@jimp/types" : "0.8.6-canary.815.488.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.8.6-canary.815.488.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.6-canary.815.488.0",
      "gitHead" : "3260b0cc7bddc7360f70248e28fdd815b7d17c8c",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.6-canary.815.488.0_1573939575621_0.30631743588117244"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.6.8" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.8",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.8.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.8.tgz",
        "shasum" : "63074984337cc469cd4030946e503e7c02a18b5c"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.6.8",
        "@jimp/plugins" : "^0.6.8",
        "@jimp/types" : "^0.6.8",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.8",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.8",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "aa937725a7db4f33c68cbab36ab5cf942f4b90ff",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.8_1567525673307_0.3978217583648782"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.9.4-canary.845.627.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.4-canary.845.627.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.4-canary.845.627.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.4-canary.845.627.0.tgz",
        "shasum" : "1afd8959e0ecbb372b41b6327a23407e1c8798d4"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.4-canary.845.627.0",
        "@jimp/plugins" : "0.9.4-canary.845.627.0",
        "@jimp/types" : "0.9.4-canary.845.627.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.4-canary.845.627.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.4-canary.845.627.0",
      "gitHead" : "cad3ef731986df2705ef1b8526c3dfe9683eb030",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.4-canary.845.627.0_1581450654092_0.9646081804940505"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.6.6" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.6",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.6.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.6.tgz",
        "shasum" : "212148b3944334cf1226dbed694d40dd4a85abdd"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.6",
        "@jimp/plugins" : "^0.6.6",
        "@jimp/types" : "^0.6.6",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.6",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.6",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "72f4171b9de0bc27cdd2a014c4da726151b8da0e",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.6_1567473506515_0.3381662849887397"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.6.7" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.7",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.7.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.7.tgz",
        "shasum" : "26c0dda9c0cf8f90b52658a9de9dbca3de635a98"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.6.7",
        "@jimp/plugins" : "^0.6.7",
        "@jimp/types" : "^0.6.7",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.6.7",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.7",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "88b63e68275c60fe0dce3056657b845bb169065c",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.7_1567473990446_0.47970712001686877"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.4.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.4.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.4.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.4.0.tgz",
        "shasum" : "19c9bb2d104e468a86f81962a99363f6f7b3be47"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "^0.4.0",
        "@jimp/plugins" : "^0.4.0",
        "@jimp/types" : "^0.4.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.4.0",
        "express" : "^4.16.3"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_from" : "file:jimp-0.4.0.tgz",
      "_npmVersion" : "6.2.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.4.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "4daa956fce81c656ffa10d814a08412ef09b7e69",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.4.0_1535929567487_0.5874166474126099"
      },
      "_resolved" : "",
      "_integrity" : "",
      "_nodeVersion" : "10.8.0"
    },
    "0.8.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2.tgz",
        "shasum" : "fe2a6ebb20209c557f0f25f4921872b859a326ff"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.8.2",
        "@jimp/plugins" : "^0.8.2",
        "@jimp/types" : "^0.8.2",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.8.2",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "c4575b6fb9f25c8bad05f05541bf195da21791e6",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2_1568396053768_0.09132576848740892"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.8.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.3",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.3.tgz",
        "shasum" : "9c6315ab9d5fab32774dbd3f58c422553f65bd03"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.8.3",
        "@jimp/plugins" : "^0.8.3",
        "@jimp/types" : "^0.8.3",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.8.3",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.3",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "42e184cf4681b71bc1594c8822be3553d152b5e2",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.3_1568849190291_0.47996028354036"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.8.4-canary.798.377.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.4-canary.798.377.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.4-canary.798.377.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.4-canary.798.377.0.tgz",
        "shasum" : "3cd2b22b9710bf6a9b49a971b24bab73f269777e"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.4-canary.798.377.0",
        "@jimp/plugins" : "0.8.4-canary.798.377.0",
        "@jimp/types" : "0.8.4-canary.798.377.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.4-canary.798.377.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.4-canary.798.377.0",
      "gitHead" : "44c5ed24135627bcd9ddf9fa47d3c78e4a37457e",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.4-canary.798.377.0_1568869741680_0.17868000929406858"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n**Note**: This change in import does not change the runtime behavior of your code at all.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.0.tgz",
        "shasum" : "03def7808d1a1bfef32d8b1e43c5400e68662c6e"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.8.0",
        "@jimp/plugins" : "^0.8.0",
        "@jimp/types" : "^0.8.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.8.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "11f2dcb229e4adeff449fbc0c8dee89586a576d3",
      "types" : "index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.0_1567876829242_0.25082008419791557"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.8.1-canary.786.217.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.786.217.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.786.217.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.786.217.0.tgz",
        "shasum" : "671b75fa3b2acc099271d44420bba130b8750a3d"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.786.217.0",
        "@jimp/plugins" : "0.8.1-canary.786.217.0",
        "@jimp/types" : "0.8.1-canary.786.217.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.786.217.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.786.217.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "f9d0b4a1a3de789557a2fedd477fbdd2a81f12c5",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.786.217.0_1568085614399_0.9733872296293882"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1.tgz",
        "shasum" : "0882942c21af348b3c80208b0bde1bad752af15c"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.8.1",
        "@jimp/plugins" : "^0.8.1",
        "@jimp/types" : "^0.8.1",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.8.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "4242e41056cdbab8080c45c22e47716864a29503",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1_1568264990991_0.6161871506064853"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.15.1-canary.924.1021.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.15.1-canary.924.1021.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.15.1-canary.924.1021.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.15.1-canary.924.1021.0.tgz",
        "shasum" : "a14a92e8966deb2194e4bc4f4d8926c7799e2181"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.15.1-canary.924.1021.0",
        "@jimp/plugins" : "0.15.1-canary.924.1021.0",
        "@jimp/types" : "0.15.1-canary.924.1021.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.15.1-canary.924.1021.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.15.1-canary.924.1021.0",
      "gitHead" : "4d135221b81927042a1c8d7ae62b58cc886d39c3",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.15.1-canary.924.1021.0_1596841098428_0.8464180082770867"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.22.0"
    },
    "0.8.2-canary.792.353.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.353.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.353.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.353.0.tgz",
        "shasum" : "9a008631ba9fb69e464e867857d0d774b57b24ec"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.353.0",
        "@jimp/plugins" : "0.8.2-canary.792.353.0",
        "@jimp/types" : "0.8.2-canary.792.353.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.353.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.353.0",
      "gitHead" : "f5db61068f71f7ceef563bbd08ab0d8f78f82454",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.353.0_1568761966698_0.523247821562832"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n**Note**: This change in import does not change the runtime behavior of your code at all.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.1-canary.786.232.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.786.232.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.786.232.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.786.232.0.tgz",
        "shasum" : "d2c58ef53896b0c5eed1029db108cb611faccf36"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.786.232.0",
        "@jimp/plugins" : "0.8.1-canary.786.232.0",
        "@jimp/types" : "0.8.1-canary.786.232.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.786.232.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.786.232.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "90bc07eac498e014b3902ebaeb341f874e8f1f19",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.786.232.0_1568135045113_0.8274555980418143"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.16.2-canary.919.1052.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.16.2-canary.919.1052.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.16.2-canary.919.1052.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.16.2-canary.919.1052.0.tgz",
        "shasum" : "39b71fba9aefb44565b8b30835632922edf35339"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.16.2-canary.919.1052.0",
        "@jimp/plugins" : "0.16.2-canary.919.1052.0",
        "@jimp/types" : "0.16.2-canary.919.1052.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.16.2-canary.919.1052.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.16.2-canary.919.1052.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "385872c90816a6a5bb1dfec7ec88651e4b523d92",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.16.2-canary.919.1052.0_1598635416241_0.39228653331363583"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.22.0"
    },
    "0.10.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.0.tgz",
        "shasum" : "df50d276b9495303c012dc8c3d0e63716c0fa7f4"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.10.0",
        "@jimp/plugins" : "^0.10.0",
        "@jimp/types" : "^0.10.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.10.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "c23237b41f76be00987a37484cf17dce3a243e2e",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.0_1585535861659_0.7869810890449109"
      },
      "_nodeVersion" : "10.19.0"
    },
    "0.9.3-canary.825.599.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.3-canary.825.599.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.3-canary.825.599.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.3-canary.825.599.0.tgz",
        "shasum" : "1c52f7ea35566006b93518e2440fea242c864bcf"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.3-canary.825.599.0",
        "@jimp/plugins" : "0.9.3-canary.825.599.0",
        "@jimp/types" : "0.9.3-canary.825.599.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.3-canary.825.599.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.3-canary.825.599.0",
      "gitHead" : "a7ca135eac68c9ed228a1cd5fe535bf9cfc0a143",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.3-canary.825.599.0_1574810487206_0.5549938475559411"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.3.9-alpha.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.9-alpha.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.9-alpha.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.9-alpha.0.tgz",
        "shasum" : "747b18e4a968e8f8a519ccf4b00d459b32d25d4c"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@jimp/custom" : "^0.3.9-alpha.0",
        "@jimp/plugins" : "^0.3.9-alpha.0",
        "@jimp/types" : "^0.3.9-alpha.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.9-alpha.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2c747d1244260e551a9476b960b64fd7a9c06cc4",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.9-alpha.0_1535415544632_0.8480340627967478"
      },
      "_nodeVersion" : "9.10.0"
    },
    "0.14.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.14.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.14.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.14.0.tgz",
        "shasum" : "fde55f69bdb918c1b01ac633d89a25853af85625"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.14.0",
        "@jimp/plugins" : "^0.14.0",
        "@jimp/types" : "^0.14.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.14.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.21.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.14.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "777081348caf314a5f35d871702168c86ab2ca3b",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.14.0_1593454056880_0.6996324753887269"
      },
      "_nodeVersion" : "10.21.0"
    },
    "0.10.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.3",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.3.tgz",
        "shasum" : "285027b49eee3418259a8e1e9a20dd078cf8b7b1"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.10.3",
        "@jimp/plugins" : "^0.10.3",
        "@jimp/types" : "^0.10.3",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.10.3",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.3",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "37197106eae5c26231018dfdc0254422f6b43927",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.3_1587412884838_0.6383975425893293"
      },
      "_nodeVersion" : "10.20.1"
    },
    "0.10.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.2",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.2.tgz",
        "shasum" : "e305dc095b04f76800f5ed776754968c127f8bf6"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.10.2",
        "@jimp/plugins" : "^0.10.2",
        "@jimp/types" : "^0.10.2",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.10.2",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.20.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.2",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "dd7a6ba5d374d273d8ef69a1832725f6c768f817",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.2_1586879237004_0.7223963999773346"
      },
      "_nodeVersion" : "10.20.0"
    },
    "0.10.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.1.tgz",
        "shasum" : "052fbf00fd955ada1bfc0f9c3a16d4980bd3178a"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.10.1",
        "@jimp/plugins" : "^0.10.1",
        "@jimp/types" : "^0.10.1",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.10.1",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.1",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "44ce60b5cc53ee60cd5c63d4dc0ecf26fd3d431e",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.1_1586110505169_0.07297651016788587"
      },
      "_nodeVersion" : "10.19.0"
    },
    "0.6.5-canary.eeb6481.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.6.5-canary.eeb6481.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.6.5-canary.eeb6481.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.6.5-canary.eeb6481.0.tgz",
        "shasum" : "3e2f4846450878bc4f23decc6886da4b93b818e4"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0",
        "@jimp/custom" : "0.6.5-canary.eeb6481.0",
        "@jimp/plugins" : "0.6.5-canary.eeb6481.0",
        "@jimp/types" : "0.6.5-canary.eeb6481.0",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.6.5-canary.eeb6481.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v10.15.0+x64 (darwin)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.6.5-canary.eeb6481.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "eeb6481c32c72c7082efa5fa9079653c513d1b27",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.6.5-canary.eeb6481.0_1567469841304_0.9186266188375907"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\nAlign Mode | Axis Point\n--- | ---\n`Jimp.HORIZONTAL_ALIGN_LEFT` | Positions the x-axis at the left of the image\n`Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image\n`Jimp.HORIZONTAL_ALIGN_RIGHT` | Positions the x-axis at the right of the image\n`Jimp.VERTICAL_ALIGN_TOP` | Positions the y-axis at the top of the image\n`Jimp.VERTICAL_ALIGN_MIDDLE` | Positions the y-axis at the center of the image\n`Jimp.VERTICAL_ALIGN_BOTTOM` | Positions the y-axis at the bottom of the image\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.15.0"
    },
    "0.8.2-canary.792.360.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.360.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.360.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.360.0.tgz",
        "shasum" : "ab8284ccd584f7a01972c2926ed6ca9f055a3af1"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.360.0",
        "@jimp/plugins" : "0.8.2-canary.792.360.0",
        "@jimp/types" : "0.8.2-canary.792.360.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.360.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.360.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "29f7a9f2419b2780dd6eeb350f6a1f500b00e1ae",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.360.0_1568840856832_0.26292741931493957"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n**Note**: This change in import does not change the runtime behavior of your code at all.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.1-canary.786.262.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.786.262.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.786.262.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.786.262.0.tgz",
        "shasum" : "f9c9a01683b82c5d0bdbfa410481442b11db1247"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.786.262.0",
        "@jimp/plugins" : "0.8.1-canary.786.262.0",
        "@jimp/types" : "0.8.1-canary.786.262.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.786.262.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.786.262.0",
      "gitHead" : "b0d5448f47e49a8ee4992dc53166a8ee32c8ee19",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.786.262.0_1568176451276_0.24721105893630768"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.3-canary.825.584.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.3-canary.825.584.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.3-canary.825.584.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.3-canary.825.584.0.tgz",
        "shasum" : "7a03b366aa0ca5794c173e86271ef81b5a6fef2a"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.3-canary.825.584.0",
        "@jimp/plugins" : "0.9.3-canary.825.584.0",
        "@jimp/types" : "0.9.3-canary.825.584.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.3-canary.825.584.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.3-canary.825.584.0",
      "gitHead" : "b52405f03464a37390ce846c22e34755347c48d2",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.3-canary.825.584.0_1574809732251_0.39965359047088445"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.16.2-canary.938.1059.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.16.2-canary.938.1059.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.16.2-canary.938.1059.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.16.2-canary.938.1059.0.tgz",
        "shasum" : "7d7a0c93dc535e32ad2f00835d4a08481d44657b"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.16.2-canary.938.1059.0",
        "@jimp/plugins" : "0.16.2-canary.938.1059.0",
        "@jimp/types" : "0.16.2-canary.938.1059.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.16.2-canary.938.1059.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.22.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.16.2-canary.938.1059.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "eac009a0e11a8dcc573ebbcb1793e49b8041a977",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.16.2-canary.938.1059.0_1599483510763_0.363373655043419"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.22.0"
    },
    "0.8.2-canary.792.349.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.349.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.349.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.349.0.tgz",
        "shasum" : "0918a7f03e752437ddcb574b9d1ce70c5580443e"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.349.0",
        "@jimp/plugins" : "0.8.2-canary.792.349.0",
        "@jimp/types" : "0.8.2-canary.792.349.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.349.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.349.0",
      "gitHead" : "c59bd6acbcca0653ca442e8be2e8aba892a7a0ca",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.349.0_1568761800743_0.7149759175029304"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.5",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.5.tgz",
        "shasum" : "78da6ddb33925cfb6b80d502d52a590b141c62ba"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.9.5",
        "@jimp/plugins" : "^0.9.5",
        "@jimp/types" : "^0.9.5",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.9.5",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.5",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "ecadad6b337ee78e23d683e9560a4182e43d9820",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.5_1583276387502_0.28412305440419283"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.9.6" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.6",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.6.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.6.tgz",
        "shasum" : "abf381daf193a4fa335cb4ee0e22948049251eb9"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.9.6",
        "@jimp/plugins" : "^0.9.6",
        "@jimp/types" : "^0.9.6",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.9.6",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.6",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "231e9e39e315aa0821d259553877e54d57e9dd6f",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.6_1584555009742_0.16780800564073228"
      },
      "_nodeVersion" : "10.19.0"
    },
    "0.9.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.3",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.3.tgz",
        "shasum" : "85e8e80eea65a7e6de806c6bb622ec6a7244e6f3"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.9.3",
        "@jimp/plugins" : "^0.9.3",
        "@jimp/types" : "^0.9.3",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.9.3",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.3",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "bcba912d188def2e9e5d2ee75109d8dfbc9fab24",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.3_1574810349074_0.3439117317122924"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.9.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.4",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.4.tgz",
        "shasum" : "463347eb1b22b00556cfd3cba39bc98f3ac8e8f9"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.9.4",
        "@jimp/plugins" : "^0.9.4",
        "@jimp/types" : "^0.9.4",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.9.4",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.4",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "a1120faa4dbe2a3ab3a465b93e5db254ec2876f2",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.4_1583275273858_0.6120107405404629"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.8.2-canary.792.290.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.290.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.290.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.290.0.tgz",
        "shasum" : "06cc4556a98082e5ce8a99f543e93857d7951542"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.290.0",
        "@jimp/plugins" : "0.8.2-canary.792.290.0",
        "@jimp/types" : "0.8.2-canary.792.290.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.290.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.290.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "9cdd4f81472c738ea7c29a55f5650cfc8bdae919",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.290.0_1568309123359_0.7127678754113647"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.9.7-canary.854.725.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.7-canary.854.725.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.7-canary.854.725.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.7-canary.854.725.0.tgz",
        "shasum" : "7df787b28636cba8f87e3af16f4dc0a59796ab14"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.7-canary.854.725.0",
        "@jimp/plugins" : "0.9.7-canary.854.725.0",
        "@jimp/types" : "0.9.7-canary.854.725.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.7-canary.854.725.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.7-canary.854.725.0",
      "gitHead" : "f94b1383a55f945130aebfa1bdecf8c2501306d5",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.7-canary.854.725.0_1584555642921_0.01851648382187343"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.19.0"
    },
    "0.9.7" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.7",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.7.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.7.tgz",
        "shasum" : "8cde94d49b6bd5b418b6849e18dc139abf7f6e38"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.9.7",
        "@jimp/plugins" : "^0.9.7",
        "@jimp/types" : "^0.9.7",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.9.7",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.7",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "c56d6f758a2404b3c4ef6682c7419cc42a0887c0",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.7_1585330908657_0.979097210883658"
      },
      "_nodeVersion" : "10.19.0"
    },
    "0.9.8" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.8",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.8.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.8.tgz",
        "shasum" : "2ee87b81b42e723ad74c73b8012f879c0abe5b04"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.9.8",
        "@jimp/plugins" : "^0.9.8",
        "@jimp/types" : "^0.9.8",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.9.8",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.8",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "3a3df33f1fcf11899075ba87811d7c3d4f9bed21",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.8_1585354453189_0.9978441389494257"
      },
      "_nodeVersion" : "10.19.0"
    },
    "0.3.3" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.3",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "./dist/jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.3.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.3.tgz",
        "shasum" : "0c6b9936bb93321c3277ae9f98b7aa1f24d66aa2"
      },
      "dependencies" : {
        "any-base" : "^1.1.0",
        "bmp-js" : "0.1.0",
        "buffer" : "^5.2.0",
        "exif-parser" : "^0.1.12",
        "file-type" : "^8.1.0",
        "jpeg-js" : "^0.3.4",
        "load-bmfont" : "^1.3.0",
        "mkdirp" : "0.5.1",
        "omggif" : "^1.0.9",
        "phin" : "^2.9.0",
        "pixelmatch" : "^4.0.2",
        "pngjs" : "^3.3.3",
        "tinycolor2" : "^1.4.1",
        "utif" : "^2.0.0"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.0.0-beta.54",
        "@babel/core" : "^7.0.0-beta.54",
        "@babel/plugin-proposal-class-properties" : "^7.0.0-beta.54",
        "@babel/plugin-syntax-object-rest-spread" : "^7.0.0-beta.54",
        "@babel/preset-env" : "^7.0.0-beta.54",
        "@babel/register" : "^7.0.0-beta.54",
        "babel-eslint" : "^8.2.6",
        "babel-plugin-add-module-exports" : "^0.3.2",
        "babel-plugin-istanbul" : "^4.1.6",
        "babel-plugin-source-map-support" : "^2.0.1",
        "babel-plugin-transform-inline-environment-variables" : "^0.4.3",
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "cross-env" : "^5.2.0",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^2.0.5",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-generic-preprocessor" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "lint-staged" : "^7.2.0",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "prettier" : "^1.13.7",
        "should" : "^13.2.2",
        "source-map-support" : "^0.5.6",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.6",
        "xo" : "^0.21.1"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "lint" : "npm run -s lint:src && npm run -s lint:tests && npm run -s lint:extra && echo Lint All Success",
        "lint:src" : "xo src/*.js src/**/*.js !src/modules/*.js",
        "lint:tests" : "xo test/*.js --global before",
        "lint:extra" : "xo {tools,examples}/*.js",
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps",
        "build:node" : "babel src -d dist --source-maps",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "6.3.0",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.3.3",
      "lint-staged" : {
        "*.{js,css,md}" : [ "prettier --write", "git add" ]
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "733d2ddbe561a2f9abcbef94a98e64d89b55d8db",
      "types" : "./jimp.d.ts",
      "husky" : {
        "hooks" : {
          "pre-commit" : "lint-staged"
        }
      },
      "browser" : "./browser/lib/jimp.js",
      "xo" : {
        "parser" : "babel-eslint",
        "extends" : [ "prettier" ],
        "plugins" : [ "prettier" ],
        "env" : [ "browser", "node", "jest" ],
        "ignores" : [ "omggif.js" ],
        "rules" : {
          "capitalized-comments" : 0,
          "unicorn/number-literal-case" : 0,
          "no-control-regex" : 1,
          "prefer-rest-params" : 1,
          "no-new" : 0,
          "no-console" : [ 2, {
            "allow" : [ "warn", "error" ]
          } ],
          "max-params" : [ 1, 6 ]
        },
        "overrides" : [ {
          "files" : "**/test/*.js",
          "esnext" : false,
          "rules" : {
            "max-nested-callbacks" : 0
          }
        } ]
      },
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.3_1533939146856_0.09909617154350991"
      },
      "prettier" : {
        "singleQuote" : true,
        "tabWidth" : 4
      },
      "_nodeVersion" : "8.11.3"
    },
    "0.3.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.4",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "./dist/jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.4.tgz",
        "shasum" : "df0bca587c28c263102dc72af712bda01a211c51"
      },
      "dependencies" : {
        "any-base" : "^1.1.0",
        "bmp-js" : "0.1.0",
        "buffer" : "^5.2.0",
        "exif-parser" : "^0.1.12",
        "file-type" : "^9.0.0",
        "jpeg-js" : "^0.3.4",
        "load-bmfont" : "^1.3.0",
        "mkdirp" : "0.5.1",
        "omggif" : "^1.0.9",
        "phin" : "^2.9.1",
        "pixelmatch" : "^4.0.2",
        "pngjs" : "^3.3.3",
        "tinycolor2" : "^1.4.1",
        "utif" : "^2.0.0"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.0.0-rc.1",
        "@babel/core" : "^7.0.0-rc.1",
        "@babel/plugin-proposal-class-properties" : "^7.0.0-rc.1",
        "@babel/plugin-syntax-object-rest-spread" : "^7.0.0-rc.1",
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@babel/preset-env" : "^7.0.0-rc.1",
        "@babel/register" : "^7.0.0-rc.1",
        "babel-eslint" : "^8.2.6",
        "babel-plugin-add-module-exports" : "^0.3.2",
        "babel-plugin-istanbul" : "^4.1.6",
        "babel-plugin-source-map-support" : "^2.0.1",
        "babel-plugin-transform-inline-environment-variables" : "^0.4.3",
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "cross-env" : "^5.2.0",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-generic-preprocessor" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "lint-staged" : "^7.2.0",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "prettier" : "^1.14.2",
        "should" : "^13.2.3",
        "source-map-support" : "^0.5.8",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "xo" : "^0.22.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "lint" : "npm run -s lint:src && npm run -s lint:tests && npm run -s lint:extra && echo Lint All Success",
        "lint:src" : "xo src/*.js src/**/*.js !src/modules/*.js",
        "lint:tests" : "xo test/*.js --global before",
        "lint:extra" : "xo {tools,examples}/*.js",
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps",
        "build:node" : "babel src -d dist --source-maps",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "6.3.0",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.3.4",
      "lint-staged" : {
        "*.{js,css,md}" : [ "prettier --write", "git add" ]
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "5565d573567a34f2fc202fc041ebdf02d283cd14",
      "types" : "./jimp.d.ts",
      "husky" : {
        "hooks" : {
          "pre-commit" : "lint-staged"
        }
      },
      "browser" : "./browser/lib/jimp.js",
      "xo" : {
        "parser" : "babel-eslint",
        "extends" : [ "prettier" ],
        "plugins" : [ "prettier" ],
        "env" : [ "browser", "node", "jest" ],
        "ignores" : [ "omggif.js" ],
        "rules" : {
          "capitalized-comments" : 0,
          "unicorn/number-literal-case" : 0,
          "no-control-regex" : 1,
          "prefer-rest-params" : 1,
          "no-new" : 0,
          "no-console" : [ 2, {
            "allow" : [ "warn", "error" ]
          } ],
          "max-params" : [ 1, 6 ]
        },
        "overrides" : [ {
          "files" : "**/test/*.js",
          "esnext" : false,
          "rules" : {
            "max-nested-callbacks" : 0
          }
        } ]
      },
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.4_1534019781420_0.13309638901726606"
      },
      "prettier" : {
        "singleQuote" : true,
        "tabWidth" : 4
      },
      "_nodeVersion" : "8.11.3"
    },
    "0.7.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.7.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.7.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.7.0.tgz",
        "shasum" : "6e4de4c329546cbae2896d4d930c99f3683a6e79"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.7.0",
        "@jimp/plugins" : "^0.7.0",
        "@jimp/types" : "^0.7.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.7.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.7.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "cd5ff6a525c0e547fb0b8172a864d98c4ed7d5fd",
      "types" : "jimp.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.7.0_1567785219665_0.9683139872925848"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.3.1" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.1",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "./dist/main/jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.1.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.1.tgz",
        "shasum" : "5d187ae8c8dfba58e3af63bebe72734e13b45adc"
      },
      "dependencies" : {
        "any-base" : "^1.1.0",
        "bmp-js" : "0.1.0",
        "buffer" : "^5.2.0",
        "exif-parser" : "^0.1.12",
        "file-type" : "^8.1.0",
        "jpeg-js" : "^0.3.4",
        "load-bmfont" : "^1.3.0",
        "mkdirp" : "0.5.1",
        "omggif" : "^1.0.9",
        "phin" : "^2.9.0",
        "pixelmatch" : "^4.0.2",
        "pngjs" : "^3.3.3",
        "tinycolor2" : "^1.4.1",
        "utif" : "^2.0.0"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.0.0-beta.54",
        "@babel/core" : "^7.0.0-beta.54",
        "@babel/plugin-proposal-class-properties" : "^7.0.0-beta.54",
        "@babel/plugin-syntax-object-rest-spread" : "^7.0.0-beta.54",
        "@babel/preset-env" : "^7.0.0-beta.54",
        "@babel/register" : "^7.0.0-beta.54",
        "babel-eslint" : "^8.2.6",
        "babel-plugin-add-module-exports" : "^0.3.2",
        "babel-plugin-istanbul" : "^4.1.6",
        "babel-plugin-source-map-support" : "^2.0.1",
        "babel-plugin-transform-inline-environment-variables" : "^0.4.3",
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "cross-env" : "^5.2.0",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^2.0.5",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-generic-preprocessor" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "lint-staged" : "^7.2.0",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "prettier" : "^1.13.7",
        "should" : "^13.2.2",
        "source-map-support" : "^0.5.6",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.6",
        "xo" : "^0.21.1"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts" ],
      "directories" : {
      },
      "scripts" : {
        "lint" : "npm run -s lint:src && npm run -s lint:tests && npm run -s lint:extra && echo Lint All Success",
        "lint:src" : "xo src/*.js src/**/*.js !src/modules/*.js",
        "lint:tests" : "xo test/*.js --global before",
        "lint:extra" : "xo {tools,examples}/*.js",
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps",
        "build:node" : "babel src -d dist/main --source-maps",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.3.1",
      "lint-staged" : {
        "*.{js,css,md}" : [ "prettier --write", "git add" ]
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "d64200c660602f10d034b31b739024153c7cbea9",
      "types" : "./jimp.d.ts",
      "husky" : {
        "hooks" : {
          "pre-commit" : "lint-staged"
        }
      },
      "browser" : "./browser/lib/jimp.js",
      "xo" : {
        "parser" : "babel-eslint",
        "extends" : [ "prettier" ],
        "plugins" : [ "prettier" ],
        "env" : [ "browser", "node", "jest" ],
        "ignores" : [ "omggif.js" ],
        "rules" : {
          "capitalized-comments" : 0,
          "unicorn/number-literal-case" : 0,
          "no-control-regex" : 1,
          "prefer-rest-params" : 1,
          "no-new" : 0,
          "no-console" : [ 2, {
            "allow" : [ "warn", "error" ]
          } ],
          "max-params" : [ 1, 6 ]
        },
        "overrides" : [ {
          "files" : "**/test/*.js",
          "esnext" : false,
          "rules" : {
            "max-nested-callbacks" : 0
          }
        } ]
      },
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.1_1533248037798_0.4337614357534334"
      },
      "prettier" : {
        "singleQuote" : true,
        "tabWidth" : 4
      },
      "_nodeVersion" : "8.11.3"
    },
    "0.3.2" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.2",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "./dist/main/jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.2.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.2.tgz",
        "shasum" : "2d1aec14be8bf5249e01f2b670400a174fb82175"
      },
      "dependencies" : {
        "any-base" : "^1.1.0",
        "bmp-js" : "0.1.0",
        "buffer" : "^5.2.0",
        "exif-parser" : "^0.1.12",
        "file-type" : "^8.1.0",
        "jpeg-js" : "^0.3.4",
        "load-bmfont" : "^1.3.0",
        "mkdirp" : "0.5.1",
        "omggif" : "^1.0.9",
        "phin" : "^2.9.0",
        "pixelmatch" : "^4.0.2",
        "pngjs" : "^3.3.3",
        "tinycolor2" : "^1.4.1",
        "utif" : "^2.0.0"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.0.0-beta.54",
        "@babel/core" : "^7.0.0-beta.54",
        "@babel/plugin-proposal-class-properties" : "^7.0.0-beta.54",
        "@babel/plugin-syntax-object-rest-spread" : "^7.0.0-beta.54",
        "@babel/preset-env" : "^7.0.0-beta.54",
        "@babel/register" : "^7.0.0-beta.54",
        "babel-eslint" : "^8.2.6",
        "babel-plugin-add-module-exports" : "^0.3.2",
        "babel-plugin-istanbul" : "^4.1.6",
        "babel-plugin-source-map-support" : "^2.0.1",
        "babel-plugin-transform-inline-environment-variables" : "^0.4.3",
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "cross-env" : "^5.2.0",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^2.0.5",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-generic-preprocessor" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "lint-staged" : "^7.2.0",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "prettier" : "^1.13.7",
        "should" : "^13.2.2",
        "source-map-support" : "^0.5.6",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.6",
        "xo" : "^0.21.1"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "lint" : "npm run -s lint:src && npm run -s lint:tests && npm run -s lint:extra && echo Lint All Success",
        "lint:src" : "xo src/*.js src/**/*.js !src/modules/*.js",
        "lint:tests" : "xo test/*.js --global before",
        "lint:extra" : "xo {tools,examples}/*.js",
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps",
        "build:node" : "babel src -d dist/main --source-maps",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "5.6.0",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.3.2",
      "lint-staged" : {
        "*.{js,css,md}" : [ "prettier --write", "git add" ]
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "54e80bc8b2febd141d704c6c34366cd9591c151d",
      "types" : "./jimp.d.ts",
      "husky" : {
        "hooks" : {
          "pre-commit" : "lint-staged"
        }
      },
      "browser" : "./browser/lib/jimp.js",
      "xo" : {
        "parser" : "babel-eslint",
        "extends" : [ "prettier" ],
        "plugins" : [ "prettier" ],
        "env" : [ "browser", "node", "jest" ],
        "ignores" : [ "omggif.js" ],
        "rules" : {
          "capitalized-comments" : 0,
          "unicorn/number-literal-case" : 0,
          "no-control-regex" : 1,
          "prefer-rest-params" : 1,
          "no-new" : 0,
          "no-console" : [ 2, {
            "allow" : [ "warn", "error" ]
          } ],
          "max-params" : [ 1, 6 ]
        },
        "overrides" : [ {
          "files" : "**/test/*.js",
          "esnext" : false,
          "rules" : {
            "max-nested-callbacks" : 0
          }
        } ]
      },
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.2_1533328931359_0.4800548139790404"
      },
      "prettier" : {
        "singleQuote" : true,
        "tabWidth" : 4
      },
      "_nodeVersion" : "8.11.3"
    },
    "0.3.7" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.7",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.7.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.7.tgz",
        "shasum" : "7132190f7383f583fff246d5bb3ff17180f5969c"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@jimp/custom" : "^0.3.7",
        "@jimp/plugins" : "^0.3.7",
        "@jimp/types" : "^0.3.7"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.7",
      "tonicExampleFilename" : "example.js",
      "types" : "jimp.d.ts",
      "licenseText" : "The MIT License (MIT)\n\nCopyright (c) 2014 Oliver Moran\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.7_1535262212113_0.08813048939828816"
      }
    },
    "0.3.8" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.8",
      "repository" : {
        "type" : "git",
        "url" : "https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.8.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.8.tgz",
        "shasum" : "2faae3187fd632ce555b0e0fae94fb9a3cbb244f"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "@jimp/custom" : "^0.3.8",
        "@jimp/plugins" : "^0.3.8",
        "@jimp/types" : "^0.3.8",
        "core-js" : "^2.5.7"
      },
      "devDependencies" : {
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "should" : "^13.2.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "watchify" : "^3.11.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.3.8",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "e04f0bb3d755b18136b00ccefc02497b7581a828",
      "types" : "jimp.d.ts",
      "licenseText" : "The MIT License (MIT)\n\nCopyright (c) 2014 Oliver Moran\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.8_1535392937069_0.23271362003932183"
      }
    },
    "0.3.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.3.5",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "./dist/jimp.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.3.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.3.5.tgz",
        "shasum" : "299a3648d306ca114cc302f7df53eebc4d6b8af6"
      },
      "dependencies" : {
        "@babel/polyfill" : "^7.0.0-rc.1",
        "any-base" : "^1.1.0",
        "bmp-js" : "0.1.0",
        "buffer" : "^5.2.0",
        "exif-parser" : "^0.1.12",
        "file-type" : "^9.0.0",
        "jpeg-js" : "^0.3.4",
        "load-bmfont" : "^1.3.0",
        "mkdirp" : "0.5.1",
        "omggif" : "^1.0.9",
        "phin" : "^2.9.1",
        "pixelmatch" : "^4.0.2",
        "pngjs" : "^3.3.3",
        "tinycolor2" : "^1.4.1",
        "utif" : "^2.0.0"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.0.0-rc.1",
        "@babel/core" : "^7.0.0-rc.1",
        "@babel/plugin-proposal-class-properties" : "^7.0.0-rc.1",
        "@babel/plugin-syntax-object-rest-spread" : "^7.0.0-rc.1",
        "@babel/preset-env" : "^7.0.0-rc.1",
        "@babel/register" : "^7.0.0-rc.1",
        "babel-eslint" : "^8.2.6",
        "babel-plugin-add-module-exports" : "^0.3.2",
        "babel-plugin-istanbul" : "^4.1.6",
        "babel-plugin-source-map-support" : "^2.0.1",
        "babel-plugin-transform-inline-environment-variables" : "^0.4.3",
        "babelify" : "^9.0.0",
        "browserify" : "^16.2.2",
        "cross-env" : "^5.2.0",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "husky" : "^1.0.0-rc.13",
        "karma" : "^3.0.0",
        "karma-browserify" : "^5.3.0",
        "karma-chrome-launcher" : "^2.2.0",
        "karma-firefox-launcher" : "^1.1.0",
        "karma-generic-preprocessor" : "^1.1.0",
        "karma-mocha" : "^1.3.0",
        "karma-mocha-reporter" : "^2.2.5",
        "lint-staged" : "^7.2.0",
        "mocha" : "^5.2.0",
        "nyc" : "^12.0.2",
        "prettier" : "^1.14.2",
        "should" : "^13.2.3",
        "source-map-support" : "^0.5.8",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.7",
        "xo" : "^0.22.0"
      },
      "license" : "MIT",
      "files" : [ "browser", "dist", "es", "jimp.d.ts", "fonts" ],
      "directories" : {
      },
      "scripts" : {
        "lint" : "npm run -s lint:src && npm run -s lint:tests && npm run -s lint:extra && echo Lint All Success",
        "lint:src" : "xo src/*.js src/**/*.js !src/modules/*.js",
        "lint:tests" : "xo test/*.js --global before",
        "lint:extra" : "xo {tools,examples}/*.js",
        "test:browser" : "cross-env BABEL_ENV=test ENV=browser CHROME_BIN=\"$(which chrome || which chromium)\" karma start --single-run",
        "test:browser:watch" : "npm run -s test:browser start -- --auto-watch",
        "test:node" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:node:watch" : "npm run test:node -- --reporter min --watch",
        "test:node:coverage" : "nyc npm run test:node",
        "test" : "npm run -s test:node:coverage && npm run -s test:browser",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps",
        "build:node" : "babel src -d dist --source-maps",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "6.3.0",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.3.5",
      "lint-staged" : {
        "*.{js,css,md}" : [ "prettier --write", "git add" ]
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "76c6849fac01a8c053668b666765bb4863c11738",
      "types" : "./jimp.d.ts",
      "husky" : {
        "hooks" : {
          "pre-commit" : "lint-staged"
        }
      },
      "browser" : "./browser/lib/jimp.js",
      "xo" : {
        "parser" : "babel-eslint",
        "extends" : [ "prettier" ],
        "plugins" : [ "prettier" ],
        "env" : [ "browser", "node", "jest" ],
        "ignores" : [ "omggif.js" ],
        "rules" : {
          "capitalized-comments" : 0,
          "unicorn/number-literal-case" : 0,
          "no-control-regex" : 1,
          "prefer-rest-params" : 1,
          "no-new" : 0,
          "no-console" : [ 2, {
            "allow" : [ "warn", "error" ]
          } ],
          "max-params" : [ 1, 6 ]
        },
        "overrides" : [ {
          "files" : "**/test/*.js",
          "esnext" : false,
          "rules" : {
            "max-nested-callbacks" : 0
          }
        } ]
      },
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.3.5_1534024955064_0.16942146415070747"
      },
      "prettier" : {
        "singleQuote" : true,
        "tabWidth" : 4
      },
      "_nodeVersion" : "8.11.3"
    },
    "0.9.6-canary.860.700.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.6-canary.860.700.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.6-canary.860.700.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.6-canary.860.700.0.tgz",
        "shasum" : "50aab8851980a45aea65176d6ec9eba16cd5952f"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.6-canary.860.700.0",
        "@jimp/plugins" : "0.9.6-canary.860.700.0",
        "@jimp/types" : "0.9.6-canary.860.700.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.6-canary.860.700.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.6-canary.860.700.0",
      "gitHead" : "b1ed4600f773ec54230e878c02c21730211f8d2a",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.6-canary.860.700.0_1584554752509_0.47343626059690913"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.19.0"
    },
    "0.8.1-canary.791.466.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.791.466.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.791.466.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.791.466.0.tgz",
        "shasum" : "b418118bac40c2187df2b4577f8e0206032e6b24"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.791.466.0",
        "@jimp/plugins" : "0.8.1-canary.791.466.0",
        "@jimp/types" : "0.8.1-canary.791.466.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.791.466.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.791.466.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "7954b0296d1da7ae878ce21b114d831575e2dfac",
      "types" : "index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.791.466.0_1570439706486_0.7785864908386975"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.5-canary.799.447.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.5-canary.799.447.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.5-canary.799.447.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.5-canary.799.447.0.tgz",
        "shasum" : "520c8502c2c395ae351cef2b129c3d1e7cd2d871"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.5-canary.799.447.0",
        "@jimp/plugins" : "0.8.5-canary.799.447.0",
        "@jimp/types" : "0.8.5-canary.799.447.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "0.8.5-canary.799.447.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.5-canary.799.447.0",
      "gitHead" : "15e06a23a3c1472e0610162322d67763962d8ffd",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.5-canary.799.447.0_1569359418466_0.6064661682558119"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\n**Note**: This change in import does not change the runtime behavior of your code at all.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.2-canary.792.283.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.2-canary.792.283.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.2-canary.792.283.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.2-canary.792.283.0.tgz",
        "shasum" : "986cc3be01c515b46a5a6533db46705577bfa69b"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.2-canary.792.283.0",
        "@jimp/plugins" : "0.8.2-canary.792.283.0",
        "@jimp/types" : "0.8.2-canary.792.283.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.2-canary.792.283.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.2-canary.792.283.0",
      "gitHead" : "72d08007f8ea0c5fe4de64e357948b758e598699",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.2-canary.792.283.0_1568301725730_0.5925412469769107"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.2.10" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.10",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.10.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.10.tgz",
        "shasum" : "3890d734d09c2335d294c967804ec2c7f520ea05"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs" : "^2.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.10",
      "gitHead" : "f90f69c5b6ced31e17d780bfb17e6dfb0addaecb",
      "_shasum" : "3890d734d09c2335d294c967804ec2c7f520ea05",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.11" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.11",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.11.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.11.tgz",
        "shasum" : "db963def8c0872ef038195aad34baf6808a258ab"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs" : "^2.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.11",
      "gitHead" : "867da510591e8258ecfa7757345bef40ca1daeac",
      "_shasum" : "db963def8c0872ef038195aad34baf6808a258ab",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.12" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.12",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.12.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.12.tgz",
        "shasum" : "5aecf8f30b5abb4edaa746aacec0f57a2859e9a5"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "es6-promise" : "^3.0.2",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pngjs" : "^2.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.12",
      "gitHead" : "6f1f18f6f8a48e29e3461ddab02009df6607d576",
      "_shasum" : "5aecf8f30b5abb4edaa746aacec0f57a2859e9a5",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.13" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.13",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.13.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.13.tgz",
        "shasum" : "92bf5f33f81653fd975e5f8b31bc1bf8d517e9a2"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "es6-promise" : "^3.0.2",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.13",
      "gitHead" : "658e7a8e7b042be903e2e002b082283bdf56ded2",
      "_shasum" : "92bf5f33f81653fd975e5f8b31bc1bf8d517e9a2",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.14" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.14",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.14.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.14.tgz",
        "shasum" : "481a3ac9131d08fff504007c6d8d1f46873b642d"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "es6-promise" : "^3.0.2",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.14",
      "gitHead" : "4a524bc4d42118c02f21ea6041d9b1e454f6876b",
      "_shasum" : "481a3ac9131d08fff504007c6d8d1f46873b642d",
      "_nodeVersion" : "0.12.7"
    },
    "0.14.0-canary.904.976.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.14.0-canary.904.976.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.14.0-canary.904.976.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.14.0-canary.904.976.0.tgz",
        "shasum" : "26650cadd8cfa7eba09316daed34ce6ae51c207c"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.14.0-canary.904.976.0",
        "@jimp/plugins" : "0.14.0-canary.904.976.0",
        "@jimp/types" : "0.14.0-canary.904.976.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.14.0-canary.904.976.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.21.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.14.0-canary.904.976.0",
      "gitHead" : "500856b2be239da7e2d0aee2d9ba9c198ff57a5c",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.14.0-canary.904.976.0_1593447720767_0.7525862003682589"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_ADD;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.21.0"
    },
    "0.2.15" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.15",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.15.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.15.tgz",
        "shasum" : "be052366c0c83dcb54880dd3815f867fd890261d"
      },
      "dependencies" : {
        "bmp-js" : "0.0.1",
        "commander" : "^2.8.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.0.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "bin" : {
        "jimp" : "cli/index.js"
      },
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.15",
      "gitHead" : "e6e9f4d59dfcab8e2cc5a7e8b453e5ead4d4f58b",
      "_shasum" : "be052366c0c83dcb54880dd3815f867fd890261d",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.16" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.16",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.16.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.16.tgz",
        "shasum" : "87fee7127775760feb48710fcab36951c7c0d577"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.16",
      "gitHead" : "3be60cefd6a479d89227c1c1199ea6356b07338c",
      "_shasum" : "87fee7127775760feb48710fcab36951c7c0d577",
      "_nodeVersion" : "0.12.7"
    },
    "0.13.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.13.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.13.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.13.0.tgz",
        "shasum" : "d5497350adaebf5dd32e4b873871fe41297cccf4"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "^0.13.0",
        "@jimp/plugins" : "^0.13.0",
        "@jimp/types" : "^0.13.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "^0.13.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.21.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.13.0",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "a29b6686e3084e6d57dc643c351979a83af9352c",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.13.0_1591337082870_0.37414492314445513"
      },
      "_nodeVersion" : "10.21.0"
    },
    "0.8.6-canary.818.495.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.6-canary.818.495.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.6-canary.818.495.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.6-canary.818.495.0.tgz",
        "shasum" : "aea63914ef4fcb750c8b0730e38938a247d35043"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.6-canary.818.495.0",
        "@jimp/plugins" : "0.8.6-canary.818.495.0",
        "@jimp/types" : "0.8.6-canary.818.495.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "0.8.6-canary.818.495.0",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.6-canary.818.495.0",
      "gitHead" : "3b326196faede3b9d88e1e9a37305cbcba7151d8",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.6-canary.818.495.0_1574198430566_0.23202723435129946"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.2.17" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.17",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.17.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.17.tgz",
        "shasum" : "4c5089071e5c07fdc30b0d84266ae328a9f7e7fe"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.17",
      "gitHead" : "23da1e1ddf2fe62d014931eb282bf80d82f1761d",
      "_shasum" : "4c5089071e5c07fdc30b0d84266ae328a9f7e7fe",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.18" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.18",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.18.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.18.tgz",
        "shasum" : "8bf486a2af80a1dd13e807da7969d275d6fcbfcd"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.18",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "dc10f423d57b18156e04af0469d5c183debf5dab",
      "_shasum" : "8bf486a2af80a1dd13e807da7969d275d6fcbfcd",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.19" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.19",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.19.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.19.tgz",
        "shasum" : "eb2296e5282dc27ad4a85a80f9d6d04c44cf1798"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.19",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "ff01600bf70084cc76f65f11dce9f6d8cdb374fa",
      "_shasum" : "eb2296e5282dc27ad4a85a80f9d6d04c44cf1798",
      "_nodeVersion" : "0.12.7"
    },
    "0.8.1-canary.786.223.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.786.223.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.786.223.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.786.223.0.tgz",
        "shasum" : "b5d94ab8d65cab9b17c6898c88b4078a6f9a1101"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.786.223.0",
        "@jimp/plugins" : "0.8.1-canary.786.223.0",
        "@jimp/types" : "0.8.1-canary.786.223.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.786.223.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.786.223.0",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "62486b053cb9cc408422e1b131813927d87edbbe",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.786.223.0_1568100896819_0.0467300332420324"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.8.1-canary.786.242.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.1-canary.786.242.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.1-canary.786.242.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.1-canary.786.242.0.tgz",
        "shasum" : "db483105dc0daf8dfff040fbeb91105649978072"
      },
      "dependencies" : {
        "@jimp/custom" : "0.8.1-canary.786.242.0",
        "@jimp/plugins" : "0.8.1-canary.786.242.0",
        "@jimp/types" : "0.8.1-canary.786.242.0",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "0.8.1-canary.786.242.0",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.1-canary.786.242.0",
      "gitHead" : "688195a6958d089e764c1cb3a874b7f7e18fa5e3",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.1-canary.786.242.0_1568161332057_0.0647656770280498"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. You can import the library with three methods\n\nFirst of all using [`import = require()`](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) method to import it as a `commonJS` module:\n\n```ts\nimport Jimp = require('jimp');\n```\n\nAlternatively you can import it with ES6 default import scheme, if you set the `esModuleInterop` compiler flag to `true` in your `tsconfig`\n\n```ts\nimport Jimp from 'jimp';\n```\n\nLastly you can import it with a synthetic default import. This requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n```ts\nimport * as Jimp from 'jimp';\n```\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "8.14.1"
    },
    "0.2.20" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.20",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.20.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.20.tgz",
        "shasum" : "a686fd2ef623148eeed3bc3fc5f3aafdeaa8ec0f"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.20",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "670cf2796687786619f8fb3699655cfe1cd2c9e9",
      "_shasum" : "a686fd2ef623148eeed3bc3fc5f3aafdeaa8ec0f",
      "_nodeVersion" : "0.12.7"
    },
    "0.2.21" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.21",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.21.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.21.tgz",
        "shasum" : "5122960cd5d5bc4196a85345f66a33b7daee4eb3"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.1",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "echo \"Error: no test specified\" && exit 1"
      },
      "_from" : ".",
      "_npmVersion" : "2.11.3",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.21",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2d3da35d0f4791b1c5a3fb12d0dc58a7e1ce456e",
      "_shasum" : "5122960cd5d5bc4196a85345f66a33b7daee4eb3",
      "_nodeVersion" : "0.12.7"
    },
    "0.9.8-canary.866.767.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.9.8-canary.866.767.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.9.8-canary.866.767.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.9.8-canary.866.767.0.tgz",
        "shasum" : "2e1d869157f4a9f735e8e3bbe1a813d66a7a0ccb"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.9.8-canary.866.767.0",
        "@jimp/plugins" : "0.9.8-canary.866.767.0",
        "@jimp/types" : "0.9.8-canary.866.767.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.9.8-canary.866.767.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.9.8-canary.866.767.0",
      "gitHead" : "b327d64410808e2be428568d217439b8e17e1d08",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.9.8-canary.866.767.0_1585349065551_0.18875508735232893"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.19.0"
    },
    "0.2.22" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.22",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.22.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.22.tgz",
        "shasum" : "3a256921102f98ddfca1694a235f598ed1a3e6ef"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.2",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^2.1.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^13.0.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.22",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "c47e382c0fc1788d2a2fa09d4b0ce1a0fddf3f7b",
      "_npmOperationalInternal" : {
        "host" : "packages-16-east.internal.npmjs.com",
        "tmp" : "tmp/jimp-0.2.22.tgz_1461281579995_0.8921706825494766"
      },
      "_shasum" : "3a256921102f98ddfca1694a235f598ed1a3e6ef",
      "_nodeVersion" : "5.4.0"
    },
    "0.2.23" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.23",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.23.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.23.tgz",
        "shasum" : "3d98143b7cef3e1907fbaa34bc2594ba5c63c975"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.2",
        "load-bmfont" : "^1.2.3",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "2.2.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^13.0.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "minify-jimp" : "uglifyjs browser/tmp.jimp.js --compress warnings=false --mangle -o browser/tmp.jimp.min.js",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.23",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "a6a4bfad75dec7595c8f9e05e717e00dd174c4b7",
      "_npmOperationalInternal" : {
        "host" : "packages-16-east.internal.npmjs.com",
        "tmp" : "tmp/jimp-0.2.23.tgz_1461721178149_0.2771739256568253"
      },
      "_shasum" : "3d98143b7cef3e1907fbaa34bc2594ba5c63c975",
      "_nodeVersion" : "5.4.0"
    },
    "0.2.24" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.24",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.24.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.24.tgz",
        "shasum" : "822961ba134f14704e60602938f4e249813c48fb"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.1.2",
        "load-bmfont" : "^1.2.3",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "2.2.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^13.0.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "minify-jimp" : "uglifyjs browser/tmp.jimp.js --compress warnings=false --mangle -o browser/tmp.jimp.min.js",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.24",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "54aef4080ed6edf67fc9a56f91364d9f89a01b49",
      "_npmOperationalInternal" : {
        "host" : "packages-16-east.internal.npmjs.com",
        "tmp" : "tmp/jimp-0.2.24.tgz_1461795429148_0.31829287740401924"
      },
      "_shasum" : "822961ba134f14704e60602938f4e249813c48fb",
      "_nodeVersion" : "5.4.0"
    },
    "0.2.25" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.25",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.25.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.25.tgz",
        "shasum" : "c77ff470edc20b281f4ea4229ec06b67894c0675"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.2.0",
        "load-bmfont" : "^1.2.3",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^3.0.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^13.0.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "minify-jimp" : "uglifyjs browser/tmp.jimp.js --compress warnings=false --mangle -o browser/tmp.jimp.min.js",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.25",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2c22ea4d4c765770aa2f3788a315da68416aca6c",
      "_npmOperationalInternal" : {
        "host" : "packages-12-west.internal.npmjs.com",
        "tmp" : "tmp/jimp-0.2.25.tgz_1470864463916_0.1363833958748728"
      },
      "_shasum" : "c77ff470edc20b281f4ea4229ec06b67894c0675",
      "_nodeVersion" : "5.4.0"
    },
    "0.2.26" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.26",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.26.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.26.tgz",
        "shasum" : "5f07e26fb3498cf13fc865f1eac4784821cf61ef"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.2.0",
        "load-bmfont" : "^1.2.3",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^3.0.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^13.0.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "minify-jimp" : "uglifyjs browser/tmp.jimp.js --compress warnings=false --mangle -o browser/tmp.jimp.min.js",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.26",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "7dafb0027a1487618f652c91092494bfcb061cfc",
      "_npmOperationalInternal" : {
        "host" : "packages-12-west.internal.npmjs.com",
        "tmp" : "tmp/jimp-0.2.26.tgz_1470957113613_0.3413048021029681"
      },
      "_shasum" : "5f07e26fb3498cf13fc865f1eac4784821cf61ef",
      "_nodeVersion" : "5.4.0"
    },
    "0.2.27" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).",
      "version" : "0.2.27",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.2.27.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.2.27.tgz",
        "shasum" : "41ef5082d8b63201d54747e04fe8bcacbaf25474"
      },
      "dependencies" : {
        "bignumber.js" : "^2.1.0",
        "bmp-js" : "0.0.1",
        "es6-promise" : "^3.0.2",
        "exif-parser" : "^0.1.9",
        "file-type" : "^3.1.0",
        "jpeg-js" : "^0.2.0",
        "load-bmfont" : "^1.2.3",
        "mime" : "^1.3.4",
        "pixelmatch" : "^4.0.0",
        "pngjs" : "^3.0.0",
        "read-chunk" : "^1.0.1",
        "request" : "^2.65.0",
        "stream-to-buffer" : "^0.1.0",
        "tinycolor2" : "^1.1.2",
        "url-regex" : "^3.0.0"
      },
      "devDependencies" : {
        "babel" : "^6.0.14",
        "babel-cli" : "^6.0.0",
        "babel-preset-es2015" : "^6.0.14",
        "babel-preset-stage-0" : "^6.0.14",
        "browserify" : "^13.0.0",
        "envify" : "^3.4.0",
        "express" : "^4.13.4",
        "uglify-js" : "^2.6.1",
        "uglifyify" : "^3.0.1"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "./test/tests.sh",
        "prepublish" : "./browser/browserify-build.sh",
        "minify-jimp" : "uglifyjs browser/tmp.jimp.js --compress warnings=false --mangle -o browser/tmp.jimp.min.js",
        "start" : "node server.js"
      },
      "_from" : ".",
      "_npmVersion" : "3.3.12",
      "_npmUser" : {
        "name" : "oliver.moran",
        "email" : "oliver@nth-iteration.ie"
      },
      "_id" : "jimp@0.2.27",
      "tonicExampleFilename" : "example.js",
      "gitHead" : "2dbb58f974dbd4f6639ca05edfd5a1f4eb1efd64",
      "_npmOperationalInternal" : {
        "host" : "packages-12-west.internal.npmjs.com",
        "tmp" : "tmp/jimp-0.2.27.tgz_1471029689729_0.8816810252610594"
      },
      "_shasum" : "41ef5082d8b63201d54747e04fe8bcacbaf25474",
      "_nodeVersion" : "5.4.0"
    },
    "0.8.4" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.4",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.4.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.4.tgz",
        "shasum" : "9c7c6ee4c8992e585a60914c62aee0c5e5c7955b"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.8.4",
        "@jimp/plugins" : "^0.8.4",
        "@jimp/types" : "^0.8.4",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@jimp/test-utils" : "^0.8.4",
        "babelify" : "^10.0.0",
        "browserify" : "^16.2.2",
        "envify" : "^4.1.0",
        "express" : "^4.16.3",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.4.9"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.13.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.4",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "ee5a809cae7cb7cc8c017e2eca935e17fd6bb5d4",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.4_1568996685088_0.15271123893359273"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.12.2-canary.899.952.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.12.2-canary.899.952.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.12.2-canary.899.952.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.12.2-canary.899.952.0.tgz",
        "shasum" : "42a47d1add1f2e3b72b1ad9236fd78040d33686c"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.12.2-canary.899.952.0",
        "@jimp/plugins" : "0.12.2-canary.899.952.0",
        "@jimp/types" : "0.12.2-canary.899.952.0",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.12.2-canary.899.952.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.21.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.12.2-canary.899.952.0",
      "gitHead" : "71319029e254af5900a70fe584994f086cba6766",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.12.2-canary.899.952.0_1591334143928_0.43023663303599546"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.21.0"
    },
    "0.8.5" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.8.5",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.8.5.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.8.5.tgz",
        "shasum" : "59427688ccc8d7a89c2165fd10d0e4164f041a9d"
      },
      "dependencies" : {
        "@jimp/custom" : "^0.8.5",
        "@jimp/plugins" : "^0.8.5",
        "@jimp/types" : "^0.8.5",
        "core-js" : "^2.5.7",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.6.0",
        "@babel/core" : "^7.6.0",
        "@babel/plugin-proposal-class-properties" : "^7.5.5",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.6.0",
        "@babel/register" : "^7.6.0",
        "@jimp/test-utils" : "^0.8.5",
        "auto" : "^7.6.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v8.14.1+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.8.5",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "gitHead" : "60b635dd77b6ea900043d81d09a12ff82fd14fd0",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.8.5_1571431956360_0.9497195400654195"
      },
      "_nodeVersion" : "8.14.1"
    },
    "0.10.1-canary.870.821.0" : {
      "name" : "jimp",
      "description" : "An image processing library written entirely in JavaScript (i.e. zero external or native dependencies)",
      "version" : "0.10.1-canary.870.821.0",
      "repository" : {
        "type" : "git",
        "url" : "git+https://github.com/oliver-moran/jimp.git"
      },
      "main" : "dist/index.js",
      "dist" : {
        "tarball" : "https://na.artifactory.swg-devops.com:443/artifactory/api/npm/fxo-cio-ies-npm-virtual/jimp/-/jimp-0.10.1-canary.870.821.0.tgz?dl=https%3A%2F%2Fregistry.npmjs.org%2Fjimp%2F-%2Fjimp-0.10.1-canary.870.821.0.tgz",
        "shasum" : "c6d238b041b2b088832cdae3b95b2ffe2470b88f"
      },
      "dependencies" : {
        "@babel/runtime" : "^7.7.2",
        "@jimp/custom" : "0.10.1-canary.870.821.0",
        "@jimp/plugins" : "0.10.1-canary.870.821.0",
        "@jimp/types" : "0.10.1-canary.870.821.0",
        "core-js" : "^3.4.1",
        "regenerator-runtime" : "^0.13.3"
      },
      "devDependencies" : {
        "@babel/cli" : "^7.7.0",
        "@babel/core" : "^7.7.2",
        "@babel/plugin-proposal-class-properties" : "^7.7.0",
        "@babel/plugin-syntax-object-rest-spread" : "^7.2.0",
        "@babel/preset-env" : "^7.7.1",
        "@babel/register" : "^7.7.0",
        "@jimp/test-utils" : "0.10.1-canary.870.821.0",
        "babel-eslint" : "^10.0.3",
        "babel-plugin-add-module-exports" : "^1.0.2",
        "babel-plugin-istanbul" : "^5.2.0",
        "babel-plugin-source-map-support" : "^2.1.1",
        "babelify" : "^10.0.0",
        "browserify" : "^16.5.0",
        "cross-env" : "^6.0.0",
        "dtslint" : "^0.9.8",
        "envify" : "^4.1.0",
        "eslint" : "^6.4.0",
        "eslint-plugin-prettier" : "^3.1.1",
        "express" : "^4.17.1",
        "husky" : "^3.0.5",
        "karma" : "^4.3.0",
        "karma-browserify" : "^6.1.0",
        "karma-chrome-launcher" : "^3.1.0",
        "karma-firefox-launcher" : "^1.2.0",
        "lerna" : "^3.16.4",
        "lerna-changelog" : "^0.8.2",
        "lint-staged" : "^9.2.5",
        "mocha" : "^6.2.0",
        "nyc" : "^14.1.1",
        "prettier" : "^1.18.2",
        "source-map-support" : "^0.5.13",
        "tfilter" : "^1.0.1",
        "uglify-js" : "^3.6.0",
        "watchify" : "^3.11.1",
        "xo" : "^0.24.0"
      },
      "license" : "MIT",
      "directories" : {
      },
      "scripts" : {
        "test" : "cross-env BABEL_ENV=test mocha --require @babel/register",
        "test:watch" : "npm run test -- --reporter min --watch",
        "test:coverage" : "nyc npm run test",
        "browser-build" : "node tools/browser-build.js test",
        "build" : "npm run build:browser && npm run build:node:production && npm run build:module",
        "build:watch" : "npm run build:node:debug -- -- --watch --verbose",
        "build:debug" : "npm run build:browser:debug && npm run build:node:debug",
        "build:module" : "cross-env BABEL_ENV=module babel src -d es --source-maps --config-file ../../babel.config.js",
        "build:node" : "babel src -d dist --source-maps --config-file ../../babel.config.js",
        "build:node:debug" : "cross-env BABEL_ENV=development npm run build:node",
        "build:node:production" : "cross-env BABEL_ENV=production npm run build:node",
        "build:browser" : "cross-env BABEL_ENV=production node tools/browser-build.js prepublish",
        "build:browser:debug" : "cross-env BABEL_ENV=development ENV=browser node tools/browser-build.js prepublish"
      },
      "_npmVersion" : "lerna/3.16.4/node@v10.19.0+x64 (linux)",
      "_npmUser" : {
        "name" : "alisowski",
        "email" : "lisowski54@gmail.com"
      },
      "_id" : "jimp@0.10.1-canary.870.821.0",
      "gitHead" : "f36f13dbe9b849efa0202e5019a991cd5d730298",
      "types" : "types/index.d.ts",
      "module" : "es/index.js",
      "_npmOperationalInternal" : {
        "host" : "s3://npm-registry-packages",
        "tmp" : "tmp/jimp_0.10.1-canary.870.821.0_1586083999606_0.5518302262140447"
      },
      "readme" : "<div align=\"center\">\n  <img width=\"200\" height=\"200\"\n    src=\"https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-11/256/crayon.png\">\n  <h1>Jimp</h1>\n  <p>JavaScript Image Manipulation Program</p>\n</div>\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nThe default jimp configuration.\n\nSupported types:\n\n- `@jimp/jpeg`\n- `@jimp/png`\n- `@jimp/bmp`\n- `@jimp/tiff`\n- `@jimp/gif`\n\n## Installation\n\n`npm install --save jimp`\n\nExample usage (Promise will never resolve if callback is passed):\n\n```js\nvar Jimp = require('jimp');\n\n// open a file called \"lenna.png\"\nJimp.read('lenna.png', (err, lenna) => {\n  if (err) throw err;\n  lenna\n    .resize(256, 256) // resize\n    .quality(60) // set JPEG quality\n    .greyscale() // set greyscale\n    .write('lena-small-bw.jpg'); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read('lenna.png')\n  .then(lenna => {\n    return lenna\n      .resize(256, 256) // resize\n      .quality(60) // set JPEG quality\n      .greyscale() // set greyscale\n      .write('lena-small-bw.jpg'); // save\n  })\n  .catch(err => {\n    console.error(err);\n  });\n```\n\n## TypeScript Usage\n\nIf you're using this library with TypeScript the method of importing slightly differs from JavaScript. Instead of using require, you must import it with ES6 default import scheme\n\n```ts\nimport Jimp from 'jimp';\n```\n\nThis requires setting the `allowSyntheticDefaultImports` compiler option to `true` in your `tsconfig`\n\n**Note 1**: `esModuleInterop` implicitly sets `allowSyntheticDefaultImports` to `true`\n\n**Note 2**: `allowSyntheticDefaultImports` nor `esModuleInterop` change the runtime behavior of your code at all. They are just flags that tells TypeScript you need the compatibility they offer.\n\n## Module Build\n\nIf you're using a web bundles (webpack, rollup, parcel) you can benefit from using the `module` build of jimp. Using the module build will allow your bundler to understand your code better and exclude things you aren't using.\n\n```js\nimport Jimp from 'jimp/es';\n```\n\n### WebPack\n\nIf you're using webpack you can set `process.browser` to true and your build of jimp will exclude certain parts, making it load faster.\n\n```js\n{\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.browser': 'true'\n    }),\n    ...\n  ],\n}\n```\n\n## Basic usage\n\nThe static `Jimp.read` method takes the path to a file, URL, dimensions, a Jimp instance or a buffer and returns a Promise:\n\n```js\nJimp.read('./path/to/image.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read('http://www.example.com/path/to/lenna.jpg')\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(jimpInstance)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n\nJimp.read(buffer)\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nIn some cases, you need to pass additional parameters with an image's URL. You can pass an object to the `Jimp.read` method:\n\n```js\nJimp.read({\n  url: 'http://www.example.com/path/to/lenna.jpg', // Required!\n  headers: {},\n  ...\n})\n  .then(image => {\n    // Do stuff with the image.\n  })\n  .catch(err => {\n    // Handle an exception.\n  });\n```\n\nJimp uses [phin](https://github.com/ethanent/phin) as it's HTTP client. Phin uses [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods for making HTTP requests. Phin parses a `url` with the `url.parse(...)` method and passes it with all the other parameters as an `options` to the [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback) or [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) methods.\n\nBriefly speaking, you can pass any options from [`http.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_http_request_options_callback), [`https.request(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/https.html#https_https_request_options_callback) or even [`tls.connect(options[, callback])`](https://nodejs.org/dist/latest-v8.x/docs/api/tls.html#tls_tls_connect_options_callback).\n\nPhin parses a `url` and combines it with any options you want. This behavior can be very useful when you need to pass some additional `headers`. Also, you can pass `rejectUnauthorized: false` if you don't require an SSL certificate to be valid (it helps to prevent `unable to verify the first certificate` error).\n\nThe convenience method `Jimp.create` also exists. It is just a wrapper around `Jimp.read`.\n\n### Custom Constructor\n\nYou might want to initialize jimp in so custom way. To do this Jimp exposes the static function `appendConstructorOption`. The appended constructor options run after all the defaults.\n\nTo define a custom constructor provide a name for it, a function to call to determine if the arguments provided to jimp match your constructor, and a function called where you can construct the image however you want.\n\n```js\nJimp.appendConstructorOption(\n  'Name of Option',\n  args => arg.hasSomeCustomThing,\n  function(resolve, reject, args) {\n    this.bitmap = customParser(args);\n    resolve();\n  }\n);\n```\n\nIf you don't want to handle parsing the bitmap. For example if you want to do some sort of authentication for URL request. Jimp exposes `parseBitmap` so you can fall back to jimp to do the heavy lifting.\n\nParse bitmap takes the raw image data in a Buffer, a path (optional), and a node style callback.\n\n```js\nJimp.appendConstructorOption('Custom Url', options => options.url, function(\n  resolve,\n  reject,\n  options\n) {\n  phin(options, (err, res) => {\n    if (err) {\n      return reject(err);\n    }\n\n    this.parseBitmap(res.body, options.url, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve();\n    });\n  });\n});\n```\n\n### Methods\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.autocrop(options);          // automatically crop same-color borders from image (if any), options may contain tolerance, cropOnlyFrames, cropSymmetric, leaveBorder\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y, [srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y, [{ mode, opacitySource, opacityDest }] );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.hasAlpha();                     // determines if an image contains opaque pixels\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversible, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone(); // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250); // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250); // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO); // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes\n\nThe following constants can be passed to the `image.cover`, `image.contain` and `image.print` methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nWhere the align mode changes the position of the associated axis as described in the table below.\n\n| Align Mode                     | Axis Point                                      |\n| ------------------------------ | ----------------------------------------------- |\n| `Jimp.HORIZONTAL_ALIGN_LEFT`   | Positions the x-axis at the left of the image   |\n| `Jimp.HORIZONTAL_ALIGN_CENTER` | Positions the x-axis at the center of the image |\n| `Jimp.HORIZONTAL_ALIGN_RIGHT`  | Positions the x-axis at the right of the image  |\n| `Jimp.VERTICAL_ALIGN_TOP`      | Positions the y-axis at the top of the image    |\n| `Jimp.VERTICAL_ALIGN_MIDDLE`   | Positions the y-axis at the center of the image |\n| `Jimp.VERTICAL_ALIGN_BOTTOM`   | Positions the y-axis at the bottom of the image |\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes for `image.cover` and `image.contain` are:\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\nDefault align modes for `image.print` are:\n\n```js\n{\n    alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT,\n    alignmentY: Jimp.VERTICAL_ALIGN_TOP\n}\n```\n\n### Compositing and blend modes\n\nThe following modes can be used for compositing two images together. mode defaults to Jimp.BLEND_SOURCE_OVER.\n\n```js\nJimp.BLEND_SOURCE_OVER;\nJimp.BLEND_DESTINATION_OVER;\nJimp.BLEND_MULTIPLY;\nJimp.BLEND_SCREEN;\nJimp.BLEND_OVERLAY;\nJimp.BLEND_DARKEN;\nJimp.BLEND_LIGHTEN;\nJimp.BLEND_HARDLIGHT;\nJimp.BLEND_DIFFERENCE;\nJimp.BLEND_EXCLUSION;\n```\n\n```js\nimage.composite(srcImage, 100, 0, {\n  mode: Jimp.BLEND_MULTIPLY,\n  opacitySource: 0.5,\n  opacityDest: 0.9\n});\n```\n\n### Writing text\n\nJimp supports basic typography using BMFont format (.fnt) even ones in different languages! Just find a bitmap font that is suitable [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  // load font from .fnt file\n  image.print(font, x, y, message); // print a message on an image. message can be a any type\n  image.print(font, x, y, message, maxWidth); // print a message on an image with text wrapped at maxWidth\n});\n```\n\nAlignment modes are supported by replacing the `str` argument with an object containing `text`, `alignmentX` and `alignmentY`. `alignmentX` defaults to `Jimp.HORIZONTAL_ALIGN_LEFT` and `alignmentY` defaults to `Jimp.VERTICAL_ALIGN_TOP`.\n\n```js\nJimp.loadFont(pathOrURL).then(font => {\n  image.print(\n    font,\n    x,\n    y,\n    {\n      text: 'Hello world!',\n      alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,\n      alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE\n    },\n    maxWidth,\n    maxHeight\n  ); // prints 'Hello world!' on an image, middle and center-aligned, when x = 0 and y = 0\n});\n```\n\n```js\nJimp.loadFont(path, cb); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK; // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK; // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK; // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK; // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK; // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK; // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK; // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE; // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE; // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE; // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE; // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(font, 10, 10, 'Hello world!');\n});\n```\n\n#### Measuring text\n\nIf you need to do calculations on where to place your text jimp provides two methods that measure how wide and how tall a piece of text will be. You can use these methods to lay out multiple pieces of text in relation to each other\n\n```js\nJimp.measureText(Jimp.FONT_SANS_32_BLACK, 'Some string'); // width of text\nJimp.measureTextHeight(Jimp.FONT_SANS_32_BLACK, 'Some string', 100); // height of text\n```\n\n#### Staggering Text\n\nIf you need to stagger text position along the x or y-axis the print method also returns the final coordinates as an argument to the callback.\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(font => {\n  image.print(\n    font,\n    10,\n    10,\n    'Hello world that wraps!',\n    50,\n    (err, image, { x, y }) => {\n      image.print(font, x, y + 20, 'More text on another line', 50);\n    }\n  );\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format. They can be used to create color font or sprite packs.\n\n:star: [Littera](http://kvazars.com/littera/)\n\n:star: [Hiero](https://github.com/libgdx/libgdx/wiki/Hiero)\n\n## Writing to files and buffers\n\n### Writing to files\n\nThe image can be written to disk in PNG, JPEG or BMP format (based on the save path extension or if no extension is provided the original image's MIME type which, if not available, defaults to PNG) using:\n\n```js\nimage.write(path, cb); // Node-style callback will be fired when write is successful\nimage.writeAsync(path); // Returns Promise\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = 'new_name.' + image.getExtension();\n//or\nvar file = 'new_name'; // with no extension\nimage.write(file);\n```\n\n### Writing to Buffers\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be generated using:\n\n```js\nimage.getBuffer(mime, cb); // Node-style callback will be fired with result\nimage.getBufferAsync(mime); // Returns Promise\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG; // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP; // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alternatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64(mime, cb); // Node-style callback will be fired with result\nimage.getBase64Async(mime); // Returns Promise\n```\n\n### PNG and JPEG quality\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality(n); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba(bool); // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType(number); // set the filter type for the saved PNG\nimage.deflateLevel(number); // set the deflate level for the saved PNG\nJimp.deflateStrategy(number); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO; // -1\nJimp.PNG_FILTER_NONE; //  0\nJimp.PNG_FILTER_SUB; //  1\nJimp.PNG_FILTER_UP; //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PATH; //  4\n```\n\n## Advanced usage\n\n### Colour manipulation\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n  { apply: 'hue', params: [-90] },\n  { apply: 'lighten', params: [50] },\n  { apply: 'xor', params: ['#06D'] }\n]);\n```\n\nThe method supports the following modifiers:\n\n| Modifier                | Description                                                                                                                                                                                                      |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                         |\n| **brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                          |\n| **desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                         |\n| **saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                |\n| **greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))                                                                                                   |\n| **spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor)) |\n| **hue** {degree}        | Alias for **spin**                                                                                                                                                                                               |\n| **mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color                                                                                                                                |\n| **tint** {amount}       | Same as applying **mix** with white color                                                                                                                                                                        |\n| **shade** {amount}      | Same as applying **mix** with black color                                                                                                                                                                        |\n| **xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components                                                                                                           |\n| **red** {amount}        | Modify Red component by a given amount                                                                                                                                                                           |\n| **green** {amount}      | Modify Green component by a given amount                                                                                                                                                                         |\n| **blue** {amount}       | Modify Blue component by a given amount                                                                                                                                                                          |\n\n### Convolution matrix\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n\n```js\nimage.convolute([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]]);\n```\n\n### Low-level manipulation\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data; // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height; // the height of the image\n```\n\nThis data can be manipulated directly, but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // x, y is the position of this pixel on the image\n  // idx is the position start position of this rgba tuple in the bitmap Buffer\n  // this is the image\n\n  var red = this.bitmap.data[idx + 0];\n  var green = this.bitmap.data[idx + 1];\n  var blue = this.bitmap.data[idx + 2];\n  var alpha = this.bitmap.data[idx + 3];\n\n  // rgba values run from 0 - 255\n  // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {\n  // do your stuff..\n\n  if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n    // image scan finished, do your stuff\n  }\n});\n```\n\nIt's possible to make an iterator scan with a `for ... of`, if you want to `break` the scan before it reaches the end, but note, that this iterator has a huge performance implication:\n\n```js\nfor (const { x, y, idx, image } of image.scanIterator(\n  0,\n  0,\n  image.bitmap.width,\n  image.bitmap.height\n)) {\n}\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y); // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex); // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\nYou can convert a css color (Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to its hexadecimal equivalent:\n\n```js\nJimp.cssColorToHex(cssColor); // e.g. converts #FF00FF to 0xFF00FFFF\n```\n\n### Creating new images\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and a Node-style callback:\n\n```js\nnew Jimp(256, 256, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nnew Jimp(256, 256, 0xff0000ff, (err, image) => {\n  // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\nOr you can use a css color format:\n\n```js\nnew Jimp(256, 256, '#FF00FF', (err, image) => {\n  // this image is 256 x 256, every pixel is set to #FF00FF\n});\n```\n\nYou can also initialize a new Jimp image with a raw image buffer:\n\n```js\nnew Jimp({ data: buffer, width: 1280, height: 768 }, (err, image) => {\n  // this image is 1280 x 768, pixels are loaded from the given buffer.\n});\n```\n\nThis can be useful for interoperating with other image processing libraries. `buffer` is expected to be four-channel (rgba) image data.\n\n## Comparing images\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image; // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to compare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponding JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg); // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n  // images match\n} else {\n  // not a match\n}\n```\n\nYou can also calculate the raw pHash (no padding or custom base). You can then use this in `distanceFromHash` to calculate the hash distance from a loaded image.\n\n```js\nconst hash1 = image1.pHash();\nconst hash2 = image2.pHash();\n\nimage2.distanceFromHash(hash1);\nJimp.compareHashes(hash1, hash2); // same result as above\n```\n\n## Chaining or callbacks\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image\n    .greyscale()\n    .scale(0.5)\n    .write('lena-half-bw.png');\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read('lenna.png').then(image => {\n  image.greyscale((err, image) => {\n    image.scale(0.5, (err, image) => {\n      image.write('lena-half-bw.png');\n    });\n  });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n",
      "typesVersions" : {
        ">=3.1.0-0" : {
          "*" : [ "types/ts3.1/index.d.ts" ]
        }
      },
      "tonicExampleFilename" : "example.js",
      "browser" : "browser/lib/jimp.js",
      "xo" : false,
      "_hasShrinkwrap" : false,
      "nyc" : {
        "sourceMap" : false,
        "instrument" : false,
        "reporter" : [ "text", "text-summary", "lcov", "html" ],
        "exclude" : [ "src/modules/*.js", "test/*.js" ]
      },
      "readmeFilename" : "README.md",
      "_nodeVersion" : "10.19.0"
    }
  },
  "readme" : "",
  "time" : {
    "0.2.4" : "2015-05-24T20:53:32.373Z",
    "0.6.0" : "2018-11-28T19:24:24.482Z",
    "0.2.5" : "2015-08-29T20:34:45.951Z",
    "0.6.1" : "2019-03-28T19:58:11.438Z",
    "0.2.2" : "2015-05-03T23:19:42.917Z",
    "0.2.3" : "2015-05-04T22:44:17.656Z",
    "0.2.8" : "2015-10-06T22:17:04.916Z",
    "0.6.4" : "2019-04-27T20:42:42.205Z",
    "0.2.9" : "2015-10-13T21:57:16.705Z",
    "0.6.5" : "2019-09-03T01:10:07.596Z",
    "0.2.6" : "2015-09-27T20:42:23.656Z",
    "0.6.2" : "2019-04-27T18:01:05.657Z",
    "0.2.7" : "2015-09-27T20:58:05.249Z",
    "0.6.3" : "2019-04-27T20:24:12.236Z",
    "0.2.28" : "2017-05-21T01:22:27.672Z",
    "0.8.1-canary.786.211.0" : "2019-09-10T02:14:00.630Z",
    "0.8.2-canary.792.332.0" : "2019-09-17T18:35:38.913Z",
    "0.10.2-canary.875.842.0" : "2020-04-14T13:25:26.564Z",
    "0.9.6-canary.857.681.0" : "2020-03-18T17:33:26.052Z",
    "0.10.5-canary.882.886.0" : "2020-05-02T03:38:54.876Z",
    "0.2.0" : "2015-05-03T01:03:06.240Z",
    "0.2.1" : "2015-05-03T13:45:49.696Z",
    "0.8.5-canary.b147e81.0" : "2019-09-24T20:49:11.007Z",
    "0.8.1-canary.789.460.0" : "2019-09-26T09:28:29.494Z",
    "0.9.6-canary.858.667.0" : "2020-03-18T16:37:36.314Z",
    "0.12.1-canary.892.924.0" : "2020-05-19T06:20:24.838Z",
    "0.10.4-canary.882.884.0" : "2020-05-02T03:37:09.705Z",
    "0.16.1" : "2020-08-28T17:21:15.427Z",
    "0.16.0" : "2020-08-08T00:27:48.340Z",
    "0.12.1" : "2020-05-19T06:30:54.654Z",
    "0.12.0" : "2020-05-17T00:34:41.895Z",
    "0.8.1-canary.789.301.0" : "2019-09-13T07:40:12.532Z",
    "0.9.4-canary.838.613.0" : "2020-01-09T15:32:42.139Z",
    "0.8.2-canary.794.308.0" : "2019-09-13T17:07:01.284Z",
    "0.9.9-canary.867.792.0" : "2020-03-29T22:46:41.669Z",
    "0.8.1-canary.791.276.0" : "2019-09-12T09:57:28.027Z",
    "0.8.5-canary.1.b147e81.0" : "2019-09-24T20:59:04.477Z",
    "0.9.4-canary.832.606.0" : "2019-12-28T00:26:40.771Z",
    "0.3.10" : "2018-08-30T02:43:03.007Z",
    "0.16.2-canary.934.1053.0" : "2020-08-28T17:24:38.818Z",
    "0.3.11" : "2018-08-30T08:18:20.336Z",
    "0.6.5-canary.784.124.0" : "2019-09-03T00:51:50.992Z",
    "0.3.9" : "2018-08-28T00:28:38.829Z",
    "0.11.1-canary.891.908.0" : "2020-05-16T18:23:45.812Z",
    "0.5.1" : "2018-09-23T20:26:27.990Z",
    "0.5.2" : "2018-09-23T20:54:20.746Z",
    "0.1.3" : "2015-01-17T23:07:44.103Z",
    "0.1.4" : "2015-01-19T00:01:30.221Z",
    "0.5.0" : "2018-09-15T20:29:25.826Z",
    "0.5.5" : "2018-10-26T01:58:17.040Z",
    "0.9.1" : "2019-11-26T17:41:09.706Z",
    "0.5.6" : "2018-10-26T02:22:18.200Z",
    "0.5.3" : "2018-09-23T21:14:43.772Z",
    "0.5.4" : "2018-10-12T06:20:44.594Z",
    "0.9.0" : "2019-11-26T17:08:40.467Z",
    "0.6.7-canary.783.157.0" : "2019-09-03T01:28:53.902Z",
    "0.1.1" : "2014-09-14T21:37:04.393Z",
    "0.1.2" : "2015-01-17T13:29:05.234Z",
    "0.1.0" : "2014-09-13T22:58:05.591Z",
    "0.8.2-canary.792.339.0" : "2019-09-17T23:02:26.893Z",
    "0.9.9-canary.868.799.0" : "2020-03-30T01:16:51.422Z",
    "0.6.5-canary.784.118.0" : "2019-09-03T00:43:49.301Z",
    "0.6.8-canary.783.163.0" : "2019-09-03T04:59:04.277Z",
    "0.6.5-canary.4564f3c.0" : "2019-09-03T00:00:15.394Z",
    "0.14.1-canary.911.993.0" : "2020-07-16T18:33:02.329Z",
    "0.10.4-canary.882.885.0" : "2020-05-02T03:36:54.092Z",
    "0.9.4-canary.841.620.0" : "2020-01-25T23:28:36.846Z",
    "0.7.1-canary.770.193.0" : "2019-09-07T02:49:15.290Z",
    "0.8.6-canary.810.481.0" : "2019-10-30T17:16:10.816Z",
    "0.15.0" : "2020-08-07T20:25:35.347Z",
    "0.11.0" : "2020-05-15T21:21:53.283Z",
    "0.8.6-canary.815.502.0" : "2019-11-19T22:14:16.701Z",
    "0.8.5-canary.800.426.0" : "2019-09-21T00:53:59.121Z",
    "0.3.6-alpha.6" : "2018-08-26T04:39:45.519Z",
    "0.9.2-canary.815.538.0" : "2019-11-26T20:14:11.088Z",
    "0.14.1-canary.919.1005.0" : "2020-07-30T11:52:01.615Z",
    "0.3.6-alpha.5" : "2018-08-26T04:23:22.440Z",
    "0.13.0-canary.899.964.0" : "2020-06-05T06:05:00.219Z",
    "0.8.6-canary.815.488.0" : "2019-11-16T21:26:15.959Z",
    "0.6.8" : "2019-09-03T15:47:53.485Z",
    "0.9.4-canary.845.627.0" : "2020-02-11T19:50:54.273Z",
    "0.6.6" : "2019-09-03T01:18:26.754Z",
    "0.6.7" : "2019-09-03T01:26:30.738Z",
    "0.4.0" : "2018-09-02T23:06:07.717Z",
    "0.8.2" : "2019-09-13T17:34:14.025Z",
    "0.8.3" : "2019-09-18T23:26:30.573Z",
    "0.8.4-canary.798.377.0" : "2019-09-19T05:09:01.881Z",
    "0.8.0" : "2019-09-07T17:20:29.463Z",
    "0.8.1-canary.786.217.0" : "2019-09-10T03:20:14.646Z",
    "0.8.1" : "2019-09-12T05:09:51.150Z",
    "0.15.1-canary.924.1021.0" : "2020-08-07T22:58:18.677Z",
    "0.8.2-canary.792.353.0" : "2019-09-17T23:12:46.935Z",
    "0.8.1-canary.786.232.0" : "2019-09-10T17:04:05.398Z",
    "0.16.2-canary.919.1052.0" : "2020-08-28T17:23:36.479Z",
    "0.10.0" : "2020-03-30T02:37:41.915Z",
    "modified" : "2020-09-07T12:58:33.704Z",
    "0.9.3-canary.825.599.0" : "2019-11-26T23:21:27.541Z",
    "0.3.9-alpha.0" : "2018-08-28T00:19:04.817Z",
    "0.14.0" : "2020-06-29T18:07:37.234Z",
    "0.10.3" : "2020-04-20T20:01:25.056Z",
    "created" : "2014-09-13T22:58:05.591Z",
    "0.10.2" : "2020-04-14T15:47:17.328Z",
    "0.10.1" : "2020-04-05T18:15:05.374Z",
    "0.6.5-canary.eeb6481.0" : "2019-09-03T00:17:21.620Z",
    "0.8.2-canary.792.360.0" : "2019-09-18T21:07:37.091Z",
    "0.8.1-canary.786.262.0" : "2019-09-11T04:34:11.540Z",
    "0.9.3-canary.825.584.0" : "2019-11-26T23:08:52.479Z",
    "0.16.2-canary.938.1059.0" : "2020-09-07T12:58:30.918Z",
    "0.8.2-canary.792.349.0" : "2019-09-17T23:10:00.995Z",
    "0.9.5" : "2020-03-03T22:59:47.662Z",
    "0.9.6" : "2020-03-18T18:10:09.973Z",
    "0.9.3" : "2019-11-26T23:19:09.301Z",
    "0.9.4" : "2020-03-03T22:41:14.087Z",
    "0.8.2-canary.792.290.0" : "2019-09-12T17:25:23.597Z",
    "0.9.7-canary.854.725.0" : "2020-03-18T18:20:43.121Z",
    "0.9.7" : "2020-03-27T17:41:48.948Z",
    "0.9.8" : "2020-03-28T00:14:13.438Z",
    "0.3.3" : "2018-08-10T22:12:27.022Z",
    "0.3.4" : "2018-08-11T20:36:21.550Z",
    "0.7.0" : "2019-09-06T15:53:39.848Z",
    "0.3.1" : "2018-08-02T22:13:57.935Z",
    "0.3.2" : "2018-08-03T20:42:11.485Z",
    "0.3.7" : "2018-08-26T05:43:32.307Z",
    "0.3.8" : "2018-08-27T18:02:17.410Z",
    "0.3.5" : "2018-08-11T22:02:35.232Z",
    "0.9.6-canary.860.700.0" : "2020-03-18T18:05:52.708Z",
    "0.8.1-canary.791.466.0" : "2019-10-07T09:15:06.797Z",
    "0.3.0" : "2018-08-01T21:16:06.097Z",
    "0.8.5-canary.799.447.0" : "2019-09-24T21:10:18.728Z",
    "0.8.2-canary.792.283.0" : "2019-09-12T15:22:05.917Z",
    "0.2.10" : "2015-10-31T15:41:29.661Z",
    "0.2.11" : "2015-11-02T08:33:25.256Z",
    "0.2.12" : "2015-11-02T19:27:07.708Z",
    "0.2.13" : "2015-11-02T22:57:41.322Z",
    "0.2.14" : "2015-11-05T19:45:03.827Z",
    "0.14.0-canary.904.976.0" : "2020-06-29T16:22:01.057Z",
    "0.2.15" : "2015-11-06T00:17:15.507Z",
    "0.2.16" : "2015-11-09T00:04:08.664Z",
    "0.13.0" : "2020-06-05T06:04:43.127Z",
    "0.8.6-canary.818.495.0" : "2019-11-19T21:20:30.963Z",
    "0.2.17" : "2015-11-09T00:57:37.778Z",
    "0.2.18" : "2015-11-09T22:16:50.629Z",
    "0.2.19" : "2015-11-09T23:09:43.131Z",
    "0.8.1-canary.786.223.0" : "2019-09-10T07:34:57.041Z",
    "0.8.1-canary.786.242.0" : "2019-09-11T00:22:12.334Z",
    "0.2.20" : "2015-12-01T00:36:39.254Z",
    "0.2.21" : "2015-12-12T21:37:21.226Z",
    "0.9.8-canary.866.767.0" : "2020-03-27T22:44:25.964Z",
    "0.2.22" : "2016-04-21T23:33:01.646Z",
    "0.2.23" : "2016-04-27T01:39:39.285Z",
    "0.2.24" : "2016-04-27T22:17:10.342Z",
    "0.2.25" : "2016-08-10T21:27:46.779Z",
    "0.2.26" : "2016-08-11T23:11:56.423Z",
    "0.2.27" : "2016-08-12T19:21:32.647Z",
    "0.8.4" : "2019-09-20T16:24:45.295Z",
    "0.12.2-canary.899.952.0" : "2020-06-05T05:15:44.256Z",
    "0.8.5" : "2019-10-18T20:52:36.555Z",
    "0.10.1-canary.870.821.0" : "2020-04-05T10:53:19.825Z"
  },
  "repository" : {
    "type" : "git",
    "url" : "git+https://github.com/oliver-moran/jimp.git"
  },
  "users" : {
    "benjamins" : true,
    "kctang" : true,
    "andriecool" : true,
    "ssljivic" : true,
    "chiefford" : true,
    "serge-nikitin" : true,
    "mgk" : true,
    "gnash48" : true,
    "nikaoto" : true,
    "avivharuzi" : true,
    "miadzadfallah" : true,
    "bobjohnson23" : true,
    "vloz" : true,
    "tsunamilei" : true,
    "meshal" : true,
    "yoda49" : true,
    "memoramirez" : true,
    "parkerproject" : true,
    "mrbgit" : true,
    "jillmolloy" : true,
    "shanewholloway" : true,
    "baddeo" : true,
    "vimcat" : true,
    "leejefon" : true,
    "fm-96" : true,
    "tanmaypatel" : true,
    "jawish" : true,
    "rocket0191" : true,
    "timmson" : true,
    "pirmax" : true,
    "langjun" : true,
    "zendayu" : true,
    "thesagarsutar" : true,
    "antanst" : true,
    "papasavva" : true,
    "vivek.vikhere" : true,
    "nickeljew" : true,
    "termosa" : true,
    "olamedia" : true,
    "septor" : true,
    "yb1997" : true,
    "nonemoticoner" : true,
    "vcarluer" : true,
    "thegreatrazz" : true,
    "karzanosman984" : true,
    "adrienhobbs" : true,
    "dillonace" : true,
    "dabeardmonsta" : true,
    "kikna" : true,
    "caleb.morris" : true,
    "kontrax" : true,
    "leon740727" : true,
    "connorthefox" : true,
    "xiaoyiyu" : true,
    "daskepon" : true,
    "liruiqing" : true,
    "irj" : true,
    "mast4461" : true,
    "wayn" : true,
    "ferx" : true,
    "suyasgulati" : true,
    "robmcguinness" : true,
    "aurium" : true,
    "radu.cojocaru" : true,
    "xupit3r" : true,
    "steel1990" : true,
    "dongxu" : true,
    "ethan_" : true,
    "mehmetkose" : true,
    "andrew.medvedev" : true,
    "ash" : true,
    "bryanch" : true,
    "monolithed" : true,
    "abuelwafa" : true,
    "jamesbedont" : true,
    "mojaray2k" : true,
    "anker" : true,
    "jens.cappelle" : true,
    "wkronmiller" : true,
    "idealley" : true,
    "romiv" : true,
    "chirag8642" : true,
    "codyschindler" : true,
    "yurii" : true,
    "rexpan" : true,
    "arefm" : true,
    "detj" : true,
    "vorg" : true,
    "michaelermer" : true,
    "heineiuo" : true,
    "shakakira" : true,
    "austinkeeley" : true,
    "fmtoffolo" : true,
    "from-nibly" : true,
    "sivashanmugam" : true,
    "huhgawz" : true,
    "zguillez" : true,
    "ederelk" : true,
    "rethinkflash" : true,
    "aravindnc" : true,
    "rochejul" : true,
    "timdp" : true,
    "mfellner" : true,
    "eerne" : true,
    "yrocq" : true,
    "robermac" : true,
    "equimper" : true,
    "psbolden" : true,
    "ffeng" : true,
    "neefrankie" : true,
    "kfir214" : true,
    "justinshea" : true,
    "jsumners" : true,
    "camario" : true,
    "pathakamar" : true,
    "otbe" : true,
    "gavatron" : true,
    "davidrapin" : true,
    "codekonami" : true,
    "syarhei" : true,
    "gpuente" : true,
    "froguard" : true,
    "actionklo" : true,
    "siyb" : true,
    "banzeh" : true,
    "donvercety" : true,
    "aditya_1806" : true,
    "yanghcc" : true,
    "hcontreras" : true,
    "oslego" : true,
    "klombomb" : true,
    "fmakareev" : true,
    "hoanganh25991" : true,
    "stagfoo" : true,
    "rparris" : true,
    "timvork" : true,
    "pooleparty" : true
  },
  "readmeFilename" : "",
  "license" : "MIT"
}